/*
 CanvasJS HTML5 & JavaScript Charts - v3.2.16 GA - https://canvasjs.com/ 
 Copyright 2021 fenopix

  --------------------- License Information --------------------
 CanvasJS is a commercial product which requires purchase of license. Without a commercial license you can use it for evaluation purposes for upto 30 days. Please refer to the following link for further details.
     https://canvasjs.com/license/

*/
/*eslint-disable*/
/*jshint ignore:start*/
(function () {
    function na(h, m) { h.prototype = cb(m.prototype); h.prototype.constructor = h; h.base = m.prototype } function cb(h) { function m() { } m.prototype = h; return new m } function Va(h, m, w) {
        "millisecond" === w ? h.setMilliseconds(h.getMilliseconds() + 1 * m) : "second" === w ? h.setSeconds(h.getSeconds() + 1 * m) : "minute" === w ? h.setMinutes(h.getMinutes() + 1 * m) : "hour" === w ? h.setHours(h.getHours() + 1 * m) : "day" === w ? h.setDate(h.getDate() + 1 * m) : "week" === w ? h.setDate(h.getDate() + 7 * m) : "month" === w ? h.setMonth(h.getMonth() + 1 * m) : "year" === w && h.setFullYear(h.getFullYear() +
            1 * m); return h
    } function Y(h, m) { var w = !1; 0 > h && (w = !0, h *= -1); h = "" + h; for (m = m ? m : 1; h.length < m;)h = "0" + h; return w ? "-" + h : h } function Ea(h) { if (!h) return h; h = h.replace(/^\s\s*/, ""); for (var m = /\s/, w = h.length; m.test(h.charAt(--w));); return h.slice(0, w + 1) } function Aa(h) {
        h.roundRect = function (h, w, s, v, qa, D, y, F) {
            y && (this.fillStyle = y); F && (this.strokeStyle = F); "undefined" === typeof qa && (qa = 5); this.lineWidth = D; this.beginPath(); this.moveTo(h + qa, w); this.lineTo(h + s - qa, w); this.quadraticCurveTo(h + s, w, h + s, w + qa); this.lineTo(h + s,
                w + v - qa); this.quadraticCurveTo(h + s, w + v, h + s - qa, w + v); this.lineTo(h + qa, w + v); this.quadraticCurveTo(h, w + v, h, w + v - qa); this.lineTo(h, w + qa); this.quadraticCurveTo(h, w, h + qa, w); this.closePath(); y && this.fill(); F && 0 < D && this.stroke()
        }
    } function Pa(h, m) { return h - m } function Q(h) { var m = ((h & 16711680) >> 16).toString(16), w = ((h & 65280) >> 8).toString(16); h = ((h & 255) >> 0).toString(16); m = 2 > m.length ? "0" + m : m; w = 2 > w.length ? "0" + w : w; h = 2 > h.length ? "0" + h : h; return "#" + m + w + h } function db(h, m) {
        var w = this.length >>> 0, s = Number(m) || 0, s = 0 > s ? Math.ceil(s) :
            Math.floor(s); for (0 > s && (s += w); s < w; s++)if (s in this && this[s] === h) return s; return -1
    } function s(h) { return null === h || "undefined" === typeof h } function Ba(h) { h.indexOf || (h.indexOf = db); return h } function eb(h) { if (T.fSDec) h[X("`eeDwdouMhrudods")](X("e`u`@ohl`uhnoHuds`uhnoDoe"), function () { T._fTWm && T._fTWm(h) }) } function Wa(h, m, w) {
        w = w || "normal"; var s = h + "_" + m + "_" + w, v = Xa[s]; if (isNaN(v)) {
            try {
                h = "position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;font-family:" +
                h + "; font-size:" + m + "px; font-weight:" + w + ";"; if (!va) { var qa = document.body; va = document.createElement("span"); va.innerHTML = ""; var D = document.createTextNode("Mpgyi"); va.appendChild(D); qa.appendChild(va) } va.style.display = ""; va.setAttribute("style", h); v = Math.round(va.offsetHeight); va.style.display = "none"
            } catch (y) { v = Math.ceil(1.1 * m) } v = Math.max(v, m); Xa[s] = v
        } return v
    } function N(h, m) {
        var w = []; if (w = {
            solid: [], shortDash: [3, 1], shortDot: [1, 1], shortDashDot: [3, 1, 1, 1], shortDashDotDot: [3, 1, 1, 1, 1, 1], dot: [1, 2], dash: [4,
                2], dashDot: [4, 2, 1, 2], longDash: [8, 2], longDashDot: [8, 2, 1, 2], longDashDotDot: [8, 2, 1, 2, 1, 2]
        }[h || "solid"]) for (var s = 0; s < w.length; s++)w[s] *= m; else w = []; return w
    } function J(h, m, w, v, Fa) {
        v = v || []; Fa = s(Fa) ? fb ? { passive: !1, capture: !1 } : !1 : Fa; v.push([h, m, w, Fa]); return h.addEventListener ? (h.addEventListener(m, w, Fa), w) : h.attachEvent ? (v = function (m) { m = m || window.event; m.preventDefault = m.preventDefault || function () { m.returnValue = !1 }; m.stopPropagation = m.stopPropagation || function () { m.cancelBubble = !0 }; w.call(h, m) }, h.attachEvent("on" +
            m, v), v) : !1
    } function gb(h) {
        if (h._menuButton) h.exportEnabled ? Ka(h._menuButton) : ta(h._menuButton); else if (h.exportEnabled && v) {
            var m = !1; h._menuButton = document.createElement("button"); ua(h, h._menuButton, "menu"); h._toolBar.appendChild(h._menuButton); J(h._menuButton, "touchstart", function (h) { m = !0 }, h.allDOMEventHandlers); J(h._menuButton, "click", function () {
                "none" !== h._dropdownMenu.style.display || h._dropDownCloseTime && 500 >= (new Date).getTime() - h._dropDownCloseTime.getTime() || (h._dropdownMenu.style.display = "block",
                    h._menuButton.blur(), h._dropdownMenu.focus())
            }, h.allDOMEventHandlers, !0); J(h._menuButton, "mouseover", function () { m || (oa(h._menuButton, { backgroundColor: h.toolbar.backgroundColorOnHover, color: h.toolbar.fontColorOnHover }), 0 >= navigator.userAgent.search("MSIE") && oa(h._menuButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" })) }, h.allDOMEventHandlers, !0); J(h._menuButton, "mouseout", function () {
                m || (oa(h._menuButton, { backgroundColor: h.toolbar.backgroundColor, color: h.toolbar.fontColor }), 0 >=
                    navigator.userAgent.search("MSIE") && oa(h._menuButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }))
            }, h.allDOMEventHandlers, !0)
        } if (!h._dropdownMenu && h.exportEnabled && v) {
            m = !1; h._dropdownMenu = document.createElement("div"); h._dropdownMenu.setAttribute("tabindex", -1); var w = -1 !== h.theme.indexOf("dark") ? "black" : "#888888"; h._dropdownMenu.style.cssText = "position: absolute; z-index: 1; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 0px;top: 25px;min-width: 120px;outline: 0;font-size: 14px; font-family: Arial, Helvetica, sans-serif;padding: 5px 0px 5px 0px;text-align: left;line-height: 10px;background-color:" +
                h.toolbar.backgroundColor + ";box-shadow: 2px 2px 10px " + w; h._dropdownMenu.style.display = "none"; h._toolBar.appendChild(h._dropdownMenu); J(h._dropdownMenu, "blur", function () { ta(h._dropdownMenu); h._dropDownCloseTime = new Date }, h.allDOMEventHandlers, !0); w = document.createElement("div"); w.style.cssText = "padding: 12px 8px 12px 8px"; w.innerHTML = h._cultureInfo.printText; w.style.backgroundColor = h.toolbar.backgroundColor; w.style.color = h.toolbar.fontColor; h._dropdownMenu.appendChild(w); J(w, "touchstart", function (h) {
                    m =
                    !0
                }, h.allDOMEventHandlers); J(w, "mouseover", function () { m || (this.style.backgroundColor = h.toolbar.backgroundColorOnHover, this.style.color = h.toolbar.fontColorOnHover) }, h.allDOMEventHandlers, !0); J(w, "mouseout", function () { m || (this.style.backgroundColor = h.toolbar.backgroundColor, this.style.color = h.toolbar.fontColor) }, h.allDOMEventHandlers, !0); J(w, "click", function () { h.print(); ta(h._dropdownMenu) }, h.allDOMEventHandlers, !0); w = document.createElement("div"); w.style.cssText = "padding: 12px 8px 12px 8px"; w.innerHTML =
                    h._cultureInfo.saveJPGText; w.style.backgroundColor = h.toolbar.backgroundColor; w.style.color = h.toolbar.fontColor; h._dropdownMenu.appendChild(w); J(w, "touchstart", function (h) { m = !0 }, h.allDOMEventHandlers); J(w, "mouseover", function () { m || (this.style.backgroundColor = h.toolbar.backgroundColorOnHover, this.style.color = h.toolbar.fontColorOnHover) }, h.allDOMEventHandlers, !0); J(w, "mouseout", function () { m || (this.style.backgroundColor = h.toolbar.backgroundColor, this.style.color = h.toolbar.fontColor) }, h.allDOMEventHandlers,
                        !0); J(w, "click", function () { h.exportChart({ format: "jpeg", fileName: h.exportFileName }); ta(h._dropdownMenu) }, h.allDOMEventHandlers, !0); w = document.createElement("div"); w.style.cssText = "padding: 12px 8px 12px 8px"; w.innerHTML = h._cultureInfo.savePNGText; w.style.backgroundColor = h.toolbar.backgroundColor; w.style.color = h.toolbar.fontColor; h._dropdownMenu.appendChild(w); J(w, "touchstart", function (h) { m = !0 }, h.allDOMEventHandlers); J(w, "mouseover", function () {
                            m || (this.style.backgroundColor = h.toolbar.backgroundColorOnHover,
                                this.style.color = h.toolbar.fontColorOnHover)
                        }, h.allDOMEventHandlers, !0); J(w, "mouseout", function () { m || (this.style.backgroundColor = h.toolbar.backgroundColor, this.style.color = h.toolbar.fontColor) }, h.allDOMEventHandlers, !0); J(w, "click", function () { h.exportChart({ format: "png", fileName: h.exportFileName }); ta(h._dropdownMenu) }, h.allDOMEventHandlers, !0)
        }
    } function Ya(h, m, w) {
        h *= ga; m *= ga; h = w.getImageData(h, m, 2, 2).data; m = !0; for (w = 0; 4 > w; w++)if (h[w] !== h[w + 4] | h[w] !== h[w + 8] | h[w] !== h[w + 12]) { m = !1; break } return m ? h[0] <<
            16 | h[1] << 8 | h[2] : 0
    } function ka(h, m, w) { return h in m ? m[h] : w[h] } function La(h, m, w) { if (v && Za) { var s = h.getContext("2d"); Ma = s.webkitBackingStorePixelRatio || s.mozBackingStorePixelRatio || s.msBackingStorePixelRatio || s.oBackingStorePixelRatio || s.backingStorePixelRatio || 1; ga = Qa / Ma; h.width = m * ga; h.height = w * ga; Qa !== Ma && (h.style.width = m + "px", h.style.height = w + "px", s.scale(ga, ga)) } else h.width = m, h.height = w } function hb(h) {
        if (!ib) {
            var m = !1, w = !1; "undefined" === typeof pa.Chart.creditHref ? (h.creditHref = X("iuuqr;..b`ow`rkr/bnl."),
                h.creditText = X("B`ow`rKR/bnl")) : (m = h.updateOption("creditText"), w = h.updateOption("creditHref")); if (h.creditHref && h.creditText) {
                    h._creditLink || (h._creditLink = document.createElement("a"), h._creditLink.setAttribute("class", "canvasjs-chart-credit"), h._creditLink.setAttribute("title", "JavaScript Charts"), h._creditLink.setAttribute("style", "outline:none;margin:0px;position:absolute;right:2px;top:" + (h.height - 14) + "px;color:dimgrey;text-decoration:none;font-size:11px;font-family: Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif"),
                        h._creditLink.setAttribute("tabIndex", -1), h._creditLink.setAttribute("target", "_blank")); if (0 === h.renderCount || m || w) h._creditLink.setAttribute("href", h.creditHref), h._creditLink.innerHTML = h.creditText; h._creditLink && h.creditHref && h.creditText ? (h._creditLink.parentElement || h._canvasJSContainer.appendChild(h._creditLink), h._creditLink.style.top = h.height - 14 + "px") : h._creditLink.parentElement && h._canvasJSContainer.removeChild(h._creditLink)
                }
        }
    } function sa(h, m) {
        Ga && (this.canvasCount |= 0, window.//////console.log(++this.canvasCount));
        var w = document.createElement("canvas"); w.setAttribute("class", "canvasjs-chart-canvas"); La(w, h, m); v || "undefined" === typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(w); return w
    } function oa(h, m) { for (var w in m) h.style[w] = m[w] } function ua(h, m, w) {
        m.getAttribute("state") || (m.style.backgroundColor = h.toolbar.backgroundColor, m.style.color = h.toolbar.fontColor, m.style.border = "none", oa(m, { WebkitUserSelect: "none", MozUserSelect: "none", msUserSelect: "none", userSelect: "none" })); m.getAttribute("state") !==
            w && (m.setAttribute("state", w), m.setAttribute("type", "button"), oa(m, { padding: "5px 12px", cursor: "pointer", "float": "left", width: "40px", height: "25px", outline: "0px", verticalAlign: "baseline", lineHeight: "0" }), m.setAttribute("title", h._cultureInfo[w + "Text"]), m.innerHTML = "<img style='height:95%; pointer-events: none;' src='" + jb[w].image + "' alt='" + h._cultureInfo[w + "Text"] + "' />")
    } function Ka() { for (var h = null, m = 0; m < arguments.length; m++)h = arguments[m], h.style && (h.style.display = "inline") } function ta() {
        for (var h =
            null, m = 0; m < arguments.length; m++)(h = arguments[m]) && h.style && (h.style.display = "none")
    } function Ra(h, m, w, s, v) { if (null === h || "undefined" === typeof h) return "undefined" === typeof w ? m : w; h = parseFloat(h.toString()) * (0 <= h.toString().indexOf("%") ? m / 100 : 1); "undefined" !== typeof s && (h = Math.min(s, h), "undefined" !== typeof v && (h = Math.max(v, h))); return !isNaN(h) && h <= m && 0 <= h ? h : "undefined" === typeof w ? m : w } function V(h, m, w, v, y) {
        this._defaultsKey = h; this._themeOptionsKey = m; this._index = v; this.parent = y; this._eventListeners = [];
        h = {}; this.theme && s(this.parent) && s(m) && s(v) ? h = s(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[m]) && (null === v ? h = this.parent.themeOptions[m] : 0 < this.parent.themeOptions[m].length && (v = Math.min(this.parent.themeOptions[m].length - 1, v), h = this.parent.themeOptions[m][v])); this.themeOptions = h; this.options = w ? w : { _isPlaceholder: !0 }; this.setOptions(this.options, h)
    } function Ca(h, m, w, s, v) {
        "undefined" ===
        typeof v && (v = 0); this._padding = v; this._x1 = h; this._y1 = m; this._x2 = w; this._y2 = s; this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding
    } function ia(h, m) { ia.base.constructor.call(this, "TextBlock", null, m, null, null); this.ctx = h; this._isDirty = !0; this._wrappedText = null; this._initialize() } function Sa(h, m) { Sa.base.constructor.call(this, "Toolbar", "toolbar", m, null, h); this.chart = h; this.canvas = h.canvas; this.ctx = this.chart.ctx; this.optionsName = "toolbar" } function xa(h, m) {
        xa.base.constructor.call(this,
            "Title", "title", m, null, h); this.chart = h; this.canvas = h.canvas; this.ctx = this.chart.ctx; this.optionsName = "title"; if (s(this.options.margin) && h.options.subtitles) for (var w = h.options.subtitles, v = 0; v < w.length; v++)if ((s(w[v].horizontalAlign) && "center" === this.horizontalAlign || w[v].horizontalAlign === this.horizontalAlign) && (s(w[v].verticalAlign) && "top" === this.verticalAlign || w[v].verticalAlign === this.verticalAlign) && !w[v].dockInsidePlotArea === !this.dockInsidePlotArea) { this.margin = 0; break } "undefined" === typeof this.options.fontSize &&
                (this.fontSize = this.chart.getAutoFontSize(this.fontSize)); this.height = this.width = null; this.bounds = { x1: null, y1: null, x2: null, y2: null }
    } function Ha(h, m, w) { Ha.base.constructor.call(this, "Subtitle", "subtitles", m, w, h); this.chart = h; this.canvas = h.canvas; this.ctx = this.chart.ctx; this.optionsName = "subtitles"; this.isOptionsInArray = !0; "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)); this.height = this.width = null; this.bounds = { x1: null, y1: null, x2: null, y2: null } } function Ta() {
        this.pool =
        []
    } function Ia(h) { var m; h && Ja[h] && (m = Ja[h]); Ia.base.constructor.call(this, "CultureInfo", null, m, null, null) } var Ga = !1, T = {}, v = !!document.createElement("canvas").getContext, pa = {
        Chart: {
            width: 500, height: 400, zoomEnabled: !1, zoomType: "x", backgroundColor: "white", theme: "light1", animationEnabled: !1, animationDuration: 1200, dataPointWidth: null, dataPointMinWidth: null, dataPointMaxWidth: null, colorSet: "colorSet1", culture: "en", creditHref: "", creditText: "CanvasJS", interactivityEnabled: !0, exportEnabled: !1, exportFileName: "Chart",
            rangeChanging: null, rangeChanged: null, publicProperties: { title: "readWrite", subtitles: "readWrite", toolbar: "readWrite", toolTip: "readWrite", legend: "readWrite", axisX: "readWrite", axisY: "readWrite", axisX2: "readWrite", axisY2: "readWrite", data: "readWrite", options: "readWrite", bounds: "readOnly", container: "readOnly", selectedColorSet: "readOnly" }
        }, Title: {
            padding: 0, text: null, verticalAlign: "top", horizontalAlign: "center", fontSize: 20, fontFamily: "Calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0,
            borderColor: "black", cornerRadius: 0, backgroundColor: v ? "transparent" : null, margin: 5, wrap: !0, maxWidth: null, dockInsidePlotArea: !1, publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
        }, Subtitle: {
            padding: 0, text: null, verticalAlign: "top", horizontalAlign: "center", fontSize: 14, fontFamily: "Calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: null, margin: 2, wrap: !0, maxWidth: null, dockInsidePlotArea: !1, publicProperties: {
                options: "readWrite",
                bounds: "readOnly", chart: "readOnly"
            }
        }, Toolbar: { backgroundColor: "white", backgroundColorOnHover: "#2196f3", borderColor: "#2196f3", borderThickness: 1, fontColor: "black", fontColorOnHover: "white", publicProperties: { options: "readWrite", chart: "readOnly" } }, Legend: {
            name: null, verticalAlign: "center", horizontalAlign: "right", fontSize: 14, fontFamily: "calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", cursor: null, itemmouseover: null, itemmouseout: null, itemmousemove: null, itemclick: null, dockInsidePlotArea: !1,
            reversed: !1, backgroundColor: v ? "transparent" : null, borderColor: v ? "transparent" : null, borderThickness: 0, cornerRadius: 0, maxWidth: null, maxHeight: null, markerMargin: null, itemMaxWidth: null, itemWidth: null, itemWrap: !0, itemTextFormatter: null, publicProperties: { options: "readWrite", bounds: "readOnly", chart: "readOnly" }
        }, ToolTip: {
            enabled: !0, shared: !1, animationEnabled: !0, content: null, contentFormatter: null, reversed: !1, backgroundColor: v ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", borderColor: null, borderThickness: 2, cornerRadius: 5,
            fontSize: 14, fontColor: "black", fontFamily: "Calibri, Arial, Georgia, serif;", fontWeight: "normal", fontStyle: "italic", updated: null, hidden: null, publicProperties: { options: "readWrite", chart: "readOnly" }
        }, Axis: {
            minimum: null, maximum: null, viewportMinimum: null, viewportMaximum: null, interval: null, intervalType: null, reversed: !1, logarithmic: !1, logarithmBase: 10, title: null, titleFontColor: "black", titleFontSize: 20, titleFontFamily: "arial", titleFontWeight: "normal", titleFontStyle: "normal", titleWrap: !0, titleMaxWidth: null,
            titleBackgroundColor: v ? "transparent" : null, titleBorderColor: v ? "transparent" : null, titleBorderThickness: 0, titleCornerRadius: 0, labelAngle: 0, labelFontFamily: "arial", labelFontColor: "black", labelFontSize: 12, labelFontWeight: "normal", labelFontStyle: "normal", labelAutoFit: !0, labelWrap: !0, labelMaxWidth: null, labelFormatter: null, labelBackgroundColor: v ? "transparent" : null, labelBorderColor: v ? "transparent" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelPlacement: "outside", labelTextAlign: "left", prefix: "", suffix: "",
            includeZero: !1, tickLength: 5, tickColor: "black", tickThickness: 1, tickPlacement: "outside", lineColor: "black", lineThickness: 1, lineDashType: "solid", gridColor: "#A0A0A0", gridThickness: 0, gridDashType: "solid", interlacedColor: v ? "transparent" : null, valueFormatString: null, margin: 2, publicProperties: { options: "readWrite", stripLines: "readWrite", scaleBreaks: "readWrite", crosshair: "readWrite", bounds: "readOnly", chart: "readOnly" }
        }, StripLine: {
            value: null, startValue: null, endValue: null, color: "orange", opacity: null, thickness: 2,
            lineDashType: "solid", label: "", labelPlacement: "inside", labelAlign: "far", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: null, labelBorderColor: v ? "transparent" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: "arial", labelFontColor: "orange", labelFontSize: 12, labelFontWeight: "normal", labelFontStyle: "normal", labelFormatter: null, showOnTop: !1, publicProperties: { options: "readWrite", axis: "readOnly", bounds: "readOnly", chart: "readOnly" }
        }, ScaleBreaks: {
            autoCalculate: !1, collapsibleThreshold: "25%",
            maxNumberOfAutoBreaks: 2, spacing: 8, type: "straight", color: "#FFFFFF", fillOpacity: 0.9, lineThickness: 2, lineColor: "#E16E6E", lineDashType: "solid", publicProperties: { options: "readWrite", customBreaks: "readWrite", axis: "readOnly", autoBreaks: "readOnly", bounds: "readOnly", chart: "readOnly" }
        }, Break: {
            startValue: null, endValue: null, spacing: 8, type: "straight", color: "#FFFFFF", fillOpacity: 0.9, lineThickness: 2, lineColor: "#E16E6E", lineDashType: "solid", publicProperties: {
                options: "readWrite", scaleBreaks: "readOnly", bounds: "readOnly",
                chart: "readOnly"
            }
        }, Crosshair: {
            enabled: !1, snapToDataPoint: !1, color: "grey", opacity: null, thickness: 2, lineDashType: "solid", label: "", labelWrap: !0, labelMaxWidth: null, labelBackgroundColor: v ? "grey" : null, labelBorderColor: v ? "grey" : null, labelBorderThickness: 0, labelCornerRadius: 0, labelFontFamily: v ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri", labelFontSize: 12, labelFontColor: "#fff", labelFontWeight: "normal", labelFontStyle: "normal", labelFormatter: null, valueFormatString: null, updated: null, hidden: null,
            publicProperties: { options: "readWrite", axis: "readOnly", bounds: "readOnly", chart: "readOnly" }
        }, DataSeries: {
            name: null, dataPoints: null, label: "", bevelEnabled: !1, highlightEnabled: !0, cursor: "default", indexLabel: "", indexLabelPlacement: "auto", indexLabelOrientation: "horizontal", indexLabelFontColor: "black", indexLabelFontSize: 12, indexLabelFontStyle: "normal", indexLabelFontFamily: "Arial", indexLabelFontWeight: "normal", indexLabelBackgroundColor: null, indexLabelLineColor: "gray", indexLabelLineThickness: 1, indexLabelLineDashType: "solid",
            indexLabelMaxWidth: null, indexLabelWrap: !0, indexLabelFormatter: null, lineThickness: 2, lineDashType: "solid", connectNullData: !1, nullDataLineDashType: "dash", color: null, lineColor: null, risingColor: "white", fallingColor: "red", fillOpacity: null, startAngle: 0, radius: null, innerRadius: null, neckHeight: null, neckWidth: null, reversed: !1, valueRepresents: null, linkedDataSeriesIndex: null, whiskerThickness: 2, whiskerDashType: "solid", whiskerColor: null, whiskerLength: null, stemThickness: 2, stemColor: null, stemDashType: "solid", upperBoxColor: "white",
            lowerBoxColor: "white", type: "column", xValueType: "number", axisXType: "primary", axisYType: "primary", axisXIndex: 0, axisYIndex: 0, xValueFormatString: null, yValueFormatString: null, zValueFormatString: null, percentFormatString: null, showInLegend: null, legendMarkerType: null, legendMarkerColor: null, legendText: null, legendMarkerBorderColor: v ? "transparent" : null, legendMarkerBorderThickness: 0, markerType: "circle", markerColor: null, markerSize: null, markerBorderColor: v ? "transparent" : null, markerBorderThickness: 0, mouseover: null,
            mouseout: null, mousemove: null, click: null, toolTipContent: null, visible: !0, publicProperties: { options: "readWrite", axisX: "readWrite", axisY: "readWrite", chart: "readOnly" }
        }, TextBlock: { x: 0, y: 0, width: null, height: null, maxWidth: null, maxHeight: null, padding: 0, angle: 0, text: "", horizontalAlign: "center", textAlign: "left", fontSize: 12, fontFamily: "calibri", fontWeight: "normal", fontColor: "black", fontStyle: "normal", borderThickness: 0, borderColor: "black", cornerRadius: 0, backgroundColor: null, textBaseline: "top" }, CultureInfo: {
            decimalSeparator: ".",
            digitGroupSeparator: ",", zoomText: "Zoom", panText: "Pan", resetText: "Reset", menuText: "More Options", saveJPGText: "Save as JPEG", savePNGText: "Save as PNG", printText: "Print", days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "), months: "January February March April May June July August September October November December".split(" "), shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
        }
    }, Ja = { en: {} }, y = v ? "Trebuchet MS, Helvetica, sans-serif" :
        "Arial", Da = v ? "Impact, Charcoal, sans-serif" : "Arial", ya = { colorSet1: "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566".split(" "), colorSet2: "#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C".split(" "), colorSet3: "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ") }, H, $, Z, da, ha; $ = "#333333"; Z = "#000000"; H = "#666666";
    ha = da = "#000000"; var U = 20, F = 14, Ua = {
        colorSet: "colorSet1", backgroundColor: "#FFFFFF", title: { fontFamily: Da, fontSize: 32, fontColor: $, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: Da, fontSize: F, fontColor: $, fontWeight: "normal", verticalAlign: "top", margin: 5 }], data: [{ indexLabelFontFamily: y, indexLabelFontSize: F, indexLabelFontColor: $, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{
            titleFontFamily: y, titleFontSize: U, titleFontColor: $, titleFontWeight: "normal", labelFontFamily: y,
            labelFontSize: F, labelFontColor: Z, labelFontWeight: "normal", lineThickness: 1, lineColor: H, tickThickness: 1, tickColor: H, gridThickness: 0, gridColor: H, stripLines: [{ labelFontFamily: y, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: {
                type: "zigzag", spacing: "2%", lineColor: "#BBBBBB",
                lineThickness: 1, lineDashType: "solid"
            }
        }], axisX2: [{
            titleFontFamily: y, titleFontSize: U, titleFontColor: $, titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: Z, labelFontWeight: "normal", lineThickness: 1, lineColor: H, tickThickness: 1, tickColor: H, gridThickness: 0, gridColor: H, stripLines: [{ labelFontFamily: y, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
                labelFontFamily: y, labelFontSize: F, labelFontColor: "#EEEEEE",
                labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash"
            }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
        }], axisY: [{
            titleFontFamily: y, titleFontSize: U, titleFontColor: $, titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: Z, labelFontWeight: "normal", lineThickness: 1, lineColor: H, tickThickness: 1, tickColor: H, gridThickness: 1, gridColor: H, stripLines: [{
                labelFontFamily: y, labelFontSize: F, labelFontColor: "#FF7300",
                labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1
            }], crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
        }], axisY2: [{
            titleFontFamily: y, titleFontSize: U, titleFontColor: $, titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: Z, labelFontWeight: "normal",
            lineThickness: 1, lineColor: H, tickThickness: 1, tickColor: H, gridThickness: 1, gridColor: H, stripLines: [{ labelFontFamily: y, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
        }], legend: {
            fontFamily: y,
            fontSize: 14, fontColor: $, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center"
        }, toolTip: { fontFamily: y, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1 }
    }; Z = $ = "#F5F5F5"; H = "#FFFFFF"; da = "#40BAF1"; ha = "#F5F5F5"; var U = 20, F = 14, $a = {
        colorSet: "colorSet2", title: { fontFamily: y, fontSize: 33, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: y, fontSize: F, fontColor: "#3A3A3A", fontWeight: "normal", verticalAlign: "top", margin: 5 }], data: [{
            indexLabelFontFamily: y,
            indexLabelFontSize: F, indexLabelFontColor: "#666666", indexLabelFontWeight: "normal", indexLabelLineThickness: 1
        }], axisX: [{
            titleFontFamily: y, titleFontSize: U, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 1, lineColor: "#BBBBBB", tickThickness: 1, tickColor: "#BBBBBB", gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{
                labelFontFamily: y, labelFontSize: F, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null,
                color: "#FFA500", thickness: 1
            }], crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
        }], axisX2: [{
            titleFontFamily: y, titleFontSize: U, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 1, lineColor: "#BBBBBB",
            tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{ labelFontFamily: y, labelFontSize: F, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }], crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
        }], axisY: [{
            titleFontFamily: y,
            titleFontSize: U, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 0, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{ labelFontFamily: y, labelFontSize: F, labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1 }], crosshair: {
                labelFontFamily: y, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal",
                labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot"
            }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
        }], axisY2: [{
            titleFontFamily: y, titleFontSize: U, titleFontColor: "#666666", titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: "#666666", labelFontWeight: "normal", lineThickness: 0, lineColor: "#BBBBBB", tickColor: "#BBBBBB", tickThickness: 1, gridThickness: 1, gridColor: "#BBBBBB", stripLines: [{
                labelFontFamily: y, labelFontSize: F,
                labelFontColor: "#FFA500", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FFA500", thickness: 1
            }], crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#EEEEEE", labelFontWeight: "normal", labelBackgroundColor: "black", color: "black", thickness: 1, lineDashType: "dot" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#BBBBBB", lineThickness: 1, lineDashType: "solid" }
        }], legend: { fontFamily: y, fontSize: 14, fontColor: "#3A3A3A", fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: {
            fontFamily: y,
            fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1
        }
    }; Z = $ = "#F5F5F5"; H = "#FFFFFF"; da = "#40BAF1"; ha = "#F5F5F5"; U = 20; F = 14; Da = {
        colorSet: "colorSet12", backgroundColor: "#2A2A2A", title: { fontFamily: Da, fontSize: 32, fontColor: $, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: Da, fontSize: F, fontColor: $, fontWeight: "normal", verticalAlign: "top", margin: 5 }], toolbar: {
            backgroundColor: "#666666", backgroundColorOnHover: "#FF7372", borderColor: "#FF7372", borderThickness: 1, fontColor: "#F5F5F5",
            fontColorOnHover: "#F5F5F5"
        }, data: [{ indexLabelFontFamily: y, indexLabelFontSize: F, indexLabelFontColor: Z, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{
            titleFontFamily: y, titleFontSize: U, titleFontColor: Z, titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: Z, labelFontWeight: "normal", lineThickness: 1, lineColor: H, tickThickness: 1, tickColor: H, gridThickness: 0, gridColor: H, stripLines: [{
                labelFontFamily: y, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null,
                color: "#FF7300", thickness: 1
            }], crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
        }], axisX2: [{
            titleFontFamily: y, titleFontSize: U, titleFontColor: Z, titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: Z, labelFontWeight: "normal", lineThickness: 1, lineColor: H, tickThickness: 1,
            tickColor: H, gridThickness: 0, gridColor: H, stripLines: [{ labelFontFamily: y, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
        }], axisY: [{
            titleFontFamily: y, titleFontSize: U,
            titleFontColor: Z, titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: Z, labelFontWeight: "normal", lineThickness: 1, lineColor: H, tickThickness: 1, tickColor: H, gridThickness: 1, gridColor: H, stripLines: [{ labelFontFamily: y, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" },
            scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
        }], axisY2: [{
            titleFontFamily: y, titleFontSize: U, titleFontColor: Z, titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: Z, labelFontWeight: "normal", lineThickness: 1, lineColor: H, tickThickness: 1, tickColor: H, gridThickness: 1, gridColor: H, stripLines: [{ labelFontFamily: y, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }],
            crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
        }], legend: { fontFamily: y, fontSize: 14, fontColor: $, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: y, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1, fontColor: Z, backgroundColor: "rgba(0, 0, 0, .7)" }
    };
    H = "#FFFFFF"; Z = $ = "#FAFAFA"; da = "#40BAF1"; ha = "#F5F5F5"; var U = 20, F = 14, ab = {
        light1: Ua, light2: $a, dark1: Da, dark2: {
            colorSet: "colorSet2", backgroundColor: "#32373A", title: { fontFamily: y, fontSize: 32, fontColor: $, fontWeight: "normal", verticalAlign: "top", margin: 5 }, subtitles: [{ fontFamily: y, fontSize: F, fontColor: $, fontWeight: "normal", verticalAlign: "top", margin: 5 }], toolbar: { backgroundColor: "#666666", backgroundColorOnHover: "#FF7372", borderColor: "#FF7372", borderThickness: 1, fontColor: "#F5F5F5", fontColorOnHover: "#F5F5F5" },
            data: [{ indexLabelFontFamily: y, indexLabelFontSize: F, indexLabelFontColor: Z, indexLabelFontWeight: "normal", indexLabelLineThickness: 1 }], axisX: [{
                titleFontFamily: y, titleFontSize: U, titleFontColor: Z, titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: Z, labelFontWeight: "normal", lineThickness: 1, lineColor: H, tickThickness: 1, tickColor: H, gridThickness: 0, gridColor: H, stripLines: [{
                    labelFontFamily: y, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300",
                    thickness: 1
                }], crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
            }], axisX2: [{
                titleFontFamily: y, titleFontSize: U, titleFontColor: Z, titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: Z, labelFontWeight: "normal", lineThickness: 1, lineColor: H, tickThickness: 1, tickColor: H,
                gridThickness: 0, gridColor: H, stripLines: [{ labelFontFamily: y, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
            }], axisY: [{
                titleFontFamily: y, titleFontSize: U, titleFontColor: Z,
                titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: Z, labelFontWeight: "normal", lineThickness: 0, lineColor: H, tickThickness: 1, tickColor: H, gridThickness: 1, gridColor: H, stripLines: [{ labelFontFamily: y, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: { labelFontFamily: y, labelFontSize: F, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash" }, scaleBreaks: {
                    type: "zigzag",
                    spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111"
                }
            }], axisY2: [{
                titleFontFamily: y, titleFontSize: U, titleFontColor: Z, titleFontWeight: "normal", labelFontFamily: y, labelFontSize: F, labelFontColor: Z, labelFontWeight: "normal", lineThickness: 0, lineColor: H, tickThickness: 1, tickColor: H, gridThickness: 1, gridColor: H, stripLines: [{ labelFontFamily: y, labelFontSize: F, labelFontColor: "#FF7300", labelFontWeight: "normal", labelBackgroundColor: null, color: "#FF7300", thickness: 1 }], crosshair: {
                    labelFontFamily: y,
                    labelFontSize: F, labelFontColor: "#000000", labelFontWeight: "normal", labelBackgroundColor: ha, color: da, thickness: 1, lineDashType: "dash"
                }, scaleBreaks: { type: "zigzag", spacing: "2%", lineColor: "#777777", lineThickness: 1, lineDashType: "solid", color: "#111111" }
            }], legend: { fontFamily: y, fontSize: 14, fontColor: $, fontWeight: "bold", verticalAlign: "bottom", horizontalAlign: "center" }, toolTip: { fontFamily: y, fontSize: 14, fontStyle: "normal", cornerRadius: 0, borderThickness: 1, fontColor: Z, backgroundColor: "rgba(0, 0, 0, .7)" }
        }, theme1: Ua,
        theme2: $a, theme3: Ua
    }, R = { numberDuration: 1, yearDuration: 314496E5, monthDuration: 2592E6, weekDuration: 6048E5, dayDuration: 864E5, hourDuration: 36E5, minuteDuration: 6E4, secondDuration: 1E3, millisecondDuration: 1, dayOfWeekFromInt: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ") }; (function () {
        T.fSDec = function (h) { for (var m = "", w = 0; w < h.length; w++)m += String.fromCharCode(Math.ceil(h.length / 57 / 5) ^ h.charCodeAt(w)); return m }; T.obj = {
            trVs: "B`ow`rKR!Ush`m", fntStr: "qy!B`mhcsh-!Mtbhe`!Fs`oed-!Mtbhe`!R`or!Tohbned-!@sh`m-!r`or,rdshg",
            txtBl: "udyuC`rdmhod", fnt: "gnou", fSy: "ghmmRuxmd", fTx: "ghmmUdyu", grClr: "fsdx", cntx: "buy", tp: "unq", msTxt: "ld`rtsdUdyu"
        }; delete pa[T.fSDec("Bi`su")][T.fSDec("bsdehuIsdg")]; T.pro = { sCH: pa[T.fSDec("Bi`su")][T.fSDec("bsdehuIsdg")] }; T.pos = ["cm", "cs", "um"]; T._fTWm = function (h) {
            if ("undefined" === typeof T.pro.sCH && !bb) try {
                var m = (new Date).getMonth() % 3, w, s, v = h[T.fSDec(T.obj.cntx)]; v[T.fSDec(T.obj.txtBl)] = T.fSDec(T.obj.tp); v[T.fSDec(T.obj.fnt)] = 11 + T.fSDec(T.obj.fntStr); v[T.fSDec(T.obj.fSy)] = T.fSDec(T.obj.grClr);
                w = "cm" === T.pos[m] || "um" === T.pos[m] ? 0 : h.width - v[T.fSDec(T.obj.msTxt)](T.fSDec(T.obj.trVs)).width; s = "um" === T.pos[m] ? 0 : h.height - 11; v[T.fSDec(T.obj.fTx)](T.fSDec(T.obj.trVs), w, s); "cs" === T.pos[m] && (h[T.fSDec("^bsdehuMhoj")].style.right = T.fSDec("`tun"))
            } catch (y) { }
        }
    })(); var fb = function () {
        var h = !1; try { var m = Object.defineProperty && Object.defineProperty({}, "passive", { get: function () { h = !0; return !1 } }); window.addEventListener && (window.addEventListener("test", null, m), window.removeEventListener("test", null, m)) } catch (w) {
            h =
            !1
        } return h
    }(), Xa = {}, va = null, kb = function () { this.ctx.clearRect(0, 0, this.width, this.height); this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height)) }, lb = function (h, m, w) { m = Math.min(this.width, this.height); return Math.max("theme4" === this.theme ? 0 : 300 <= m ? 12 : 11, Math.round(m * (h / 400))) }, za = function () {
        var h = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g, m = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
        w = "Sun Mon Tue Wed Thu Fri Sat".split(" "), s = "January February March April May June July August September October November December".split(" "), v = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), y = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, D = /[^-+\dA-Z]/g; return function (F, N, M) {
            var T = M ? M.days : m, H = M ? M.months : s, Q = M ? M.shortDays : w, J = M ? M.shortMonths : v; M = ""; var R = !1; F = F && F.getTime ? F : F ? new Date(F) : new Date;
            if (isNaN(F)) throw SyntaxError("invalid date"); "UTC:" === N.slice(0, 4) && (N = N.slice(4), R = !0); M = R ? "getUTC" : "get"; var V = F[M + "Date"](), L = F[M + "Day"](), W = F[M + "Month"](), a = F[M + "FullYear"](), d = F[M + "Hours"](), c = F[M + "Minutes"](), b = F[M + "Seconds"](), e = F[M + "Milliseconds"](), f = R ? 0 : F.getTimezoneOffset(); return M = N.replace(h, function (l) {
                switch (l) {
                    case "D": return V; case "DD": return Y(V, 2); case "DDD": return Q[L]; case "DDDD": return T[L]; case "M": return W + 1; case "MM": return Y(W + 1, 2); case "MMM": return J[W]; case "MMMM": return H[W];
                    case "Y": return parseInt(String(a).slice(-2)); case "YY": return Y(String(a).slice(-2), 2); case "YYY": return Y(String(a).slice(-3), 3); case "YYYY": return Y(a, 4); case "h": return d % 12 || 12; case "hh": return Y(d % 12 || 12, 2); case "H": return d; case "HH": return Y(d, 2); case "m": return c; case "mm": return Y(c, 2); case "s": return b; case "ss": return Y(b, 2); case "f": return Y(String(e), 3).slice(0, 1); case "ff": return Y(String(e), 3).slice(0, 2); case "fff": return Y(String(e), 3).slice(0, 3); case "t": return 12 > d ? "a" : "p"; case "tt": return 12 >
                        d ? "am" : "pm"; case "T": return 12 > d ? "A" : "P"; case "TT": return 12 > d ? "AM" : "PM"; case "K": return R ? "UTC" : (String(F).match(y) || [""]).pop().replace(D, ""); case "z": return (0 < f ? "-" : "+") + Math.floor(Math.abs(f) / 60); case "zz": return (0 < f ? "-" : "+") + Y(Math.floor(Math.abs(f) / 60), 2); case "zzz": return (0 < f ? "-" : "+") + Y(Math.floor(Math.abs(f) / 60), 2) + Y(Math.abs(f) % 60, 2); default: return l.slice(1, l.length - 1)
                }
            })
        }
    }(), ea = function (h, m, w) {
        if (null === h) return ""; if (!isFinite(h)) return h; h = Number(h); var s = 0 > h ? !0 : !1; s && (h *= -1); var v = w ?
            w.decimalSeparator : ".", y = w ? w.digitGroupSeparator : ",", D = ""; m = String(m); var D = 1, F = w = "", N = -1, M = [], T = [], H = 0, Q = 0, R = 0, J = !1, V = 0, F = m.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g); m = null; for (var L = 0; F && L < F.length; L++)if (m = F[L], "." === m && 0 > N) N = L; else {
                if ("%" === m) D *= 100; else if ("\u2030" === m) { D *= 1E3; continue } else if ("," === m[0] && "." === m[m.length - 1]) { D /= Math.pow(1E3, m.length - 1); N = L + m.length - 1; continue } else "E" !== m[0] && "e" !== m[0] || "0" !== m[m.length - 1] || (J = !0); 0 > N ? (M.push(m), "#" === m || "0" === m ? H++ : "," === m &&
                    R++) : (T.push(m), "#" !== m && "0" !== m || Q++)
            } J && (m = Math.floor(h), F = -Math.floor(Math.log(h) / Math.LN10 + 1), V = 0 === h ? 0 : 0 === m ? -(H + F) : String(m).length - H, D /= Math.pow(10, V)); 0 > N && (N = L); D = (h * D).toFixed(Q); m = D.split("."); D = (m[0] + "").split(""); h = (m[1] + "").split(""); D && "0" === D[0] && D.shift(); for (J = F = L = Q = N = 0; 0 < M.length;)if (m = M.pop(), "#" === m || "0" === m) if (N++, N === H) { var W = D, D = []; if ("0" === m) for (m = H - Q - (W ? W.length : 0); 0 < m;)W.unshift("0"), m--; for (; 0 < W.length;)w = W.pop() + w, J++, 0 === J % F && (L === R && 0 < W.length) && (w = y + w) } else 0 < D.length ?
                (w = D.pop() + w, Q++, J++) : "0" === m && (w = "0" + w, Q++, J++), 0 === J % F && (L === R && 0 < D.length) && (w = y + w); else "E" !== m[0] && "e" !== m[0] || "0" !== m[m.length - 1] || !/[eE][+-]*[0]+/.test(m) ? "," === m ? (L++, F = J, J = 0, 0 < D.length && (w = y + w)) : w = 1 < m.length && ('"' === m[0] && '"' === m[m.length - 1] || "'" === m[0] && "'" === m[m.length - 1]) ? m.slice(1, m.length - 1) + w : m + w : (m = 0 > V ? m.replace("+", "").replace("-", "") : m.replace("-", ""), w += m.replace(/[0]+/, function (a) { return Y(V, a.length) })); y = ""; for (M = !1; 0 < T.length;)m = T.shift(), "#" === m || "0" === m ? 0 < h.length && 0 !== Number(h.join("")) ?
                    (y += h.shift(), M = !0) : "0" === m && (y += "0", M = !0) : 1 < m.length && ('"' === m[0] && '"' === m[m.length - 1] || "'" === m[0] && "'" === m[m.length - 1]) ? y += m.slice(1, m.length - 1) : "E" !== m[0] && "e" !== m[0] || "0" !== m[m.length - 1] || !/[eE][+-]*[0]+/.test(m) ? y += m : (m = 0 > V ? m.replace("+", "").replace("-", "") : m.replace("-", ""), y += m.replace(/[0]+/, function (a) { return Y(V, a.length) })); w += (M ? v : "") + y; return s ? "-" + w : w
    }, Na = function (h) {
        var m = 0, w = 0; h = h || window.event; h.offsetX || 0 === h.offsetX ? (m = h.offsetX, w = h.offsetY) : h.layerX || 0 == h.layerX ? (m = h.layerX, w =
            h.layerY) : (m = h.pageX - h.target.offsetLeft, w = h.pageY - h.target.offsetTop); return { x: m, y: w }
    }, Za = !0, Qa = window.devicePixelRatio || 1, Ma = 1, ga = Za ? Qa / Ma : 1, ca = function (h, m, w, s, v, y, D, F, N, M, T, Q, J) {
        "undefined" === typeof J && (J = 1); D = D || 0; F = F || "black"; var H = 15 < s - m && 15 < v - w ? 8 : 0.35 * Math.min(s - m, v - w); h.beginPath(); h.moveTo(m, w); h.save(); h.fillStyle = y; h.globalAlpha = J; h.fillRect(m, w, s - m, v - w); h.globalAlpha = 1; 0 < D && (J = 0 === D % 2 ? 0 : 0.5, h.beginPath(), h.lineWidth = D, h.strokeStyle = F, h.moveTo(m, w), h.rect(m - J, w - J, s - m + 2 * J, v - w + 2 * J), h.stroke());
        h.restore(); !0 === N && (h.save(), h.beginPath(), h.moveTo(m, w), h.lineTo(m + H, w + H), h.lineTo(s - H, w + H), h.lineTo(s, w), h.closePath(), D = h.createLinearGradient((s + m) / 2, w + H, (s + m) / 2, w), D.addColorStop(0, y), D.addColorStop(1, "rgba(255, 255, 255, .4)"), h.fillStyle = D, h.fill(), h.restore()); !0 === M && (h.save(), h.beginPath(), h.moveTo(m, v), h.lineTo(m + H, v - H), h.lineTo(s - H, v - H), h.lineTo(s, v), h.closePath(), D = h.createLinearGradient((s + m) / 2, v - H, (s + m) / 2, v), D.addColorStop(0, y), D.addColorStop(1, "rgba(255, 255, 255, .4)"), h.fillStyle =
            D, h.fill(), h.restore()); !0 === T && (h.save(), h.beginPath(), h.moveTo(m, w), h.lineTo(m + H, w + H), h.lineTo(m + H, v - H), h.lineTo(m, v), h.closePath(), D = h.createLinearGradient(m + H, (v + w) / 2, m, (v + w) / 2), D.addColorStop(0, y), D.addColorStop(1, "rgba(255, 255, 255, 0.1)"), h.fillStyle = D, h.fill(), h.restore()); !0 === Q && (h.save(), h.beginPath(), h.moveTo(s, w), h.lineTo(s - H, w + H), h.lineTo(s - H, v - H), h.lineTo(s, v), D = h.createLinearGradient(s - H, (v + w) / 2, s, (v + w) / 2), D.addColorStop(0, y), D.addColorStop(1, "rgba(255, 255, 255, 0.1)"), h.fillStyle =
                D, D.addColorStop(0, y), D.addColorStop(1, "rgba(255, 255, 255, 0.1)"), h.fillStyle = D, h.fill(), h.closePath(), h.restore())
    }, X = function (h) { for (var m = "", s = 0; s < h.length; s++)m += String.fromCharCode(Math.ceil(h.length / 57 / 5) ^ h.charCodeAt(s)); return m }, bb = window && window[X("mnb`uhno")] && window[X("mnb`uhno")].href && window[X("mnb`uhno")].href.indexOf && (-1 !== window[X("mnb`uhno")].href.indexOf(X("b`ow`rkr/bnl")) || -1 !== window[X("mnb`uhno")].href.indexOf(X("gdonqhy/bnl")) || -1 !== window[X("mnb`uhno")].href.indexOf(X("gheemd"))),
        ib = bb && -1 === window[X("mnb`uhno")].href.indexOf(X("gheemd")), jb = {
            reset: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg==" },
            pan: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC" },
            zoom: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII=" },
            menu: { image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC" }
        };
    V.prototype.setOptions = function (h, m) { if (pa[this._defaultsKey]) { var s = pa[this._defaultsKey], v; for (v in s) "publicProperties" !== v && s.hasOwnProperty(v) && (this[v] = h && v in h ? h[v] : m && v in m ? m[v] : s[v]) } else Ga && window.//console && //////console.log("defaults not set") }; V.prototype.get = function (h) {
        var m = pa[this._defaultsKey]; if ("options" === h) return this.options && this.options._isPlaceholder ? null : this.options; if (m.hasOwnProperty(h) || m.publicProperties && m.publicProperties.hasOwnProperty(h)) return this[h]; window.//console &&
            window.//////console.log('Property "' + h + "\" doesn't exist. Please check for typo.")
    }; V.prototype.set = function (h, m, s) {
        s = "undefined" === typeof s ? !0 : s; var v = pa[this._defaultsKey]; if ("options" === h) this.createUserOptions(m); else if (v.hasOwnProperty(h) || v.publicProperties && v.publicProperties.hasOwnProperty(h) && "readWrite" === v.publicProperties[h]) this.options._isPlaceholder && this.createUserOptions(), this.options[h] = m; else {
            window.//console && (v.publicProperties && v.publicProperties.hasOwnProperty(h) && "readOnly" === v.publicProperties[h] ?
                window.//////console.log('Property "' + h + '" is read-only.') : window.//////console.log('Property "' + h + "\" doesn't exist. Please check for typo.")); return
        } s && (this.stockChart || this.chart || this).render()
    }; V.prototype.addTo = function (h, m, s, v) {
        v = "undefined" === typeof v ? !0 : v; var y = pa[this._defaultsKey]; y.hasOwnProperty(h) || y.publicProperties && y.publicProperties.hasOwnProperty(h) && "readWrite" === y.publicProperties[h] ? (this.options._isPlaceholder && this.createUserOptions(), "undefined" === typeof this.options[h] && (this.options[h] =
            []), h = this.options[h], s = "undefined" === typeof s || null === s ? h.length : s, h.splice(s, 0, m), v && (this.stockChart || this.chart || this).render()) : window.//console && (y.publicProperties && y.publicProperties.hasOwnProperty(h) && "readOnly" === y.publicProperties[h] ? window.//////console.log('Property "' + h + '" is read-only.') : window.//////console.log('Property "' + h + "\" doesn't exist. Please check for typo."))
    }; V.prototype.createUserOptions = function (h) {
        if ("undefined" !== typeof h || this.options._isPlaceholder) if (this.parent.options._isPlaceholder &&
            this.parent.createUserOptions(), this.isOptionsInArray) { this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []); var m = this.parent.options[this.optionsName], s = m.length; this.options._isPlaceholder || (Ba(m), s = m.indexOf(this.options)); this.options = "undefined" === typeof h ? {} : h; m[s] = this.options } else this.options = "undefined" === typeof h ? {} : h, h = this.parent.options, this.optionsName ? m = this.optionsName : (m = this._defaultsKey) && 0 !== m.length ? (s = m.charAt(0).toLowerCase(), 1 < m.length && (s = s.concat(m.slice(1))),
                m = s) : m = void 0, h[m] = this.options
    }; V.prototype.remove = function (h) { h = "undefined" === typeof h ? !0 : h; if (this.isOptionsInArray) { var m = this.parent.options[this.optionsName]; Ba(m); var s = m.indexOf(this.options); 0 <= s && m.splice(s, 1) } else delete this.parent.options[this.optionsName]; h && (this.stockChart || this.chart || this).render() }; V.prototype.updateOption = function (h) {
        !pa[this._defaultsKey] && (Ga && window.//console) && //////console.log("defaults not set"); var m = pa[this._defaultsKey], v = {}, y = this[h], F = this._themeOptionsKey,
            H = this._index; this.theme && s(this.parent) && s(F) && s(H) ? v = s(this.predefinedThemes[this.theme]) ? this.predefinedThemes.light1 : this.predefinedThemes[this.theme] : this.parent && (this.parent.themeOptions && this.parent.themeOptions[F]) && (null === H ? v = this.parent.themeOptions[F] : 0 < this.parent.themeOptions[F].length && (v = Math.min(this.parent.themeOptions[F].length - 1, H), v = this.parent.themeOptions[F][v])); this.themeOptions = v; h in m && (y = h in this.options ? this.options[h] : v && h in v ? v[h] : m[h]); if (y === this[h]) return !1; this[h] =
                y; return !0
    }; V.prototype.trackChanges = function (h) { if (!this.sessionVariables) throw "Session Variable Store not set"; this.sessionVariables[h] = this.options[h] }; V.prototype.isBeingTracked = function (h) { this.options._oldOptions || (this.options._oldOptions = {}); return this.options._oldOptions[h] ? !0 : !1 }; V.prototype.hasOptionChanged = function (h) { if (!this.sessionVariables) throw "Session Variable Store not set"; return this.sessionVariables[h] !== this.options[h] }; V.prototype.addEventListener = function (h, m, s) {
        h && m && (this._eventListeners[h] =
            this._eventListeners[h] || [], this._eventListeners[h].push({ context: s || this, eventHandler: m }))
    }; V.prototype.removeEventListener = function (h, m) { if (h && m && this._eventListeners[h]) for (var s = this._eventListeners[h], v = 0; v < s.length; v++)if (s[v].eventHandler === m) { s[v].splice(v, 1); break } }; V.prototype.removeAllEventListeners = function () { this._eventListeners = [] }; V.prototype.dispatchEvent = function (h, m, s) {
        if (h && this._eventListeners[h]) {
            m = m || {}; for (var v = this._eventListeners[h], y = 0; y < v.length; y++)v[y].eventHandler.call(v[y].context,
                m)
        } "function" === typeof this[h] && this[h].call(s || this.chart, m)
    }; Ca.prototype.registerSpace = function (h, m) { "top" === h ? this._topOccupied += m.height : "bottom" === h ? this._bottomOccupied += m.height : "left" === h ? this._leftOccupied += m.width : "right" === h && (this._rightOccupied += m.width) }; Ca.prototype.unRegisterSpace = function (h, m) { "top" === h ? this._topOccupied -= m.height : "bottom" === h ? this._bottomOccupied -= m.height : "left" === h ? this._leftOccupied -= m.width : "right" === h && (this._rightOccupied -= m.width) }; Ca.prototype.getFreeSpace =
        function () { return { x1: this._x1 + this._leftOccupied, y1: this._y1 + this._topOccupied, x2: this._x2 - this._rightOccupied, y2: this._y2 - this._bottomOccupied, width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied, height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied } }; Ca.prototype.reset = function () { this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding }; na(ia, V); ia.prototype._initialize = function () {
            s(this.padding) || "object" !== typeof this.padding ? this.topPadding =
                this.rightPadding = this.bottomPadding = this.leftPadding = Number(this.padding) | 0 : (this.topPadding = s(this.padding.top) ? 0 : Number(this.padding.top) | 0, this.rightPadding = s(this.padding.right) ? 0 : Number(this.padding.right) | 0, this.bottomPadding = s(this.padding.bottom) ? 0 : Number(this.padding.bottom) | 0, this.leftPadding = s(this.padding.left) ? 0 : Number(this.padding.left) | 0)
        }; ia.prototype.render = function (h) {
            if (0 !== this.fontSize) {
                h && this.ctx.save(); var m = this.ctx.font; this.ctx.textBaseline = this.textBaseline; var s = 0; this._isDirty &&
                    this.measureText(this.ctx); this.ctx.translate(this.x, this.y + s); "middle" === this.textBaseline && (s = -this._lineHeight / 2); this.ctx.font = this._getFontString(); this.ctx.rotate(Math.PI / 180 * this.angle); var v = 0, y = this.topPadding, F = null; this.ctx.roundRect || Aa(this.ctx); (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(0, s, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor); this.ctx.fillStyle = this.fontColor; for (s = 0; s < this._wrappedText.lines.length; s++) {
                        F =
                        this._wrappedText.lines[s]; if ("right" === this.horizontalAlign || "right" === this.textAlign) v = this.width - F.width - this.rightPadding; else if ("left" === this.horizontalAlign || "left" === this.textAlign) v = this.leftPadding; else if ("center" === this.horizontalAlign || "center" === this.textAlign) v = (this.width - (this.leftPadding + this.rightPadding)) / 2 - F.width / 2 + this.leftPadding; this.ctx.fillText(F.text, v, y); y += F.height
                    } this.ctx.font = m; h && this.ctx.restore()
            }
        }; ia.prototype.setText = function (h) {
            this.text = h; this._isDirty = !0; this._wrappedText =
                null
        }; ia.prototype.measureText = function () { this._lineHeight = Wa(this.fontFamily, this.fontSize, this.fontWeight); if (null === this.maxWidth) throw "Please set maxWidth and height for TextBlock"; this._wrapText(this.ctx); this._isDirty = !1; return { width: this.width, height: this.height } }; ia.prototype._getLineWithWidth = function (h, m, s) {
            h = String(h); if (!h) return { text: "", width: 0 }; var v = s = 0, y = h.length - 1, F = Infinity; for (this.ctx.font = this._getFontString(); v <= y;) {
                var F = Math.floor((v + y) / 2), D = h.substr(0, F + 1); s = this.ctx.measureText(D).width;
                if (s < m) v = F + 1; else if (s > m) y = F - 1; else break
            } s > m && 1 < D.length && (D = D.substr(0, D.length - 1), s = this.ctx.measureText(D).width); m = !0; if (D.length === h.length || " " === h[D.length]) m = !1; m && (h = D.split(" "), 1 < h.length && h.pop(), D = h.join(" "), s = this.ctx.measureText(D).width); return { text: D, width: s }
        }; ia.prototype._wrapText = function () {
            var h = new String(Ea(String(this.text))), m = [], s = this.ctx.font, v = 0, y = 0; this.ctx.font = this._getFontString(); if (0 === this.frontSize) y = v = 0; else for (; 0 < h.length;) {
                var F = this.maxHeight - (this.topPadding +
                    this.bottomPadding), D = this._getLineWithWidth(h, this.maxWidth - (this.leftPadding + this.rightPadding), !1); D.height = this._lineHeight; m.push(D); var H = y, y = Math.max(y, D.width), v = v + D.height, h = Ea(h.slice(D.text.length, h.length)); F && v > F && (D = m.pop(), v -= D.height, y = H)
            } this._wrappedText = { lines: m, width: y, height: v }; this.width = y + (this.leftPadding + this.rightPadding); this.height = v + (this.topPadding + this.bottomPadding); this.ctx.font = s
        }; ia.prototype._getFontString = function () {
            var h; h = "" + (this.fontStyle ? this.fontStyle + " " :
                ""); h += this.fontWeight ? this.fontWeight + " " : ""; h += this.fontSize ? this.fontSize + "px " : ""; var m = this.fontFamily ? this.fontFamily + "" : ""; !v && m && (m = m.split(",")[0], "'" !== m[0] && '"' !== m[0] && (m = "'" + m + "'")); return h += m
        }; na(Sa, V); na(xa, V); xa.prototype.setLayout = function () {
            if (this.text) {
                var h = this.dockInsidePlotArea ? this.chart.plotArea : this.chart, m = h.layoutManager.getFreeSpace(), v = m.x1, y = m.y1, F = 0, H = 0, D = this.chart._menuButton && this.chart.exportEnabled && "top" === this.verticalAlign ? 22 : 0, N, J; "top" === this.verticalAlign ||
                    "bottom" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = m.width - 4 - D * ("center" === this.horizontalAlign ? 2 : 1)), H = 0.5 * m.height - this.margin - 2, F = 0) : "center" === this.verticalAlign && ("left" === this.horizontalAlign || "right" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = m.height - 4), H = 0.5 * m.width - this.margin - 2) : "center" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = m.width - 4), H = 0.5 * m.height - 4)); var M; s(this.padding) || "number" !== typeof this.padding ? s(this.padding) || "object" !==
                        typeof this.padding || (M = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, M += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0) : M = 2 * this.padding; this.wrap || (H = Math.min(H, 1.5 * this.fontSize + M)); H = new ia(this.ctx, {
                            fontSize: this.fontSize, fontFamily: this.fontFamily, fontColor: this.fontColor, fontStyle: this.fontStyle, fontWeight: this.fontWeight, horizontalAlign: this.horizontalAlign, verticalAlign: this.verticalAlign, borderColor: this.borderColor, borderThickness: this.borderThickness,
                            backgroundColor: this.backgroundColor, maxWidth: this.maxWidth, maxHeight: H, cornerRadius: this.cornerRadius, text: this.text, padding: this.padding, textBaseline: "top"
                        }); M = H.measureText(); "top" === this.verticalAlign || "bottom" === this.verticalAlign ? ("top" === this.verticalAlign ? (y = m.y1 + 2, J = "top") : "bottom" === this.verticalAlign && (y = m.y2 - 2 - M.height, J = "bottom"), "left" === this.horizontalAlign ? v = m.x1 + 2 : "center" === this.horizontalAlign ? v = m.x1 + m.width / 2 - M.width / 2 : "right" === this.horizontalAlign && (v = m.x2 - 2 - M.width - D), N = this.horizontalAlign,
                            this.width = M.width, this.height = M.height) : "center" === this.verticalAlign && ("left" === this.horizontalAlign ? (v = m.x1 + 2, y = m.y2 - 2 - (this.maxWidth / 2 - M.width / 2), F = -90, J = "left", this.width = M.height, this.height = M.width) : "right" === this.horizontalAlign ? (v = m.x2 - 2, y = m.y1 + 2 + (this.maxWidth / 2 - M.width / 2), F = 90, J = "right", this.width = M.height, this.height = M.width) : "center" === this.horizontalAlign && (y = h.y1 + (h.height / 2 - M.height / 2), v = h.x1 + (h.width / 2 - M.width / 2), J = "center", this.width = M.width, this.height = M.height), N = "center"); H.x =
                                v; H.y = y; H.angle = F; H.horizontalAlign = N; this._textBlock = H; h.layoutManager.registerSpace(J, { width: this.width + ("left" === J || "right" === J ? this.margin + 2 : 0), height: this.height + ("top" === J || "bottom" === J ? this.margin + 2 : 0) }); this.bounds = { x1: v, y1: y, x2: v + this.width, y2: y + this.height }; this.ctx.textBaseline = "top"
            }
        }; xa.prototype.render = function () { this._textBlock && this._textBlock.render(!0) }; na(Ha, V); Ha.prototype.setLayout = xa.prototype.setLayout; Ha.prototype.render = xa.prototype.render; Ta.prototype.get = function (h, m) {
            var v =
                null; 0 < this.pool.length ? (v = this.pool.pop(), La(v, h, m)) : v = sa(h, m); return v
        }; Ta.prototype.release = function (h) { this.pool.push(h) }; na(Ia, V); var Oa = { addTheme: function (h, m) { ab[h] = m }, addColorSet: function (h, m) { ya[h] = m }, addCultureInfo: function (h, m) { Ja[h] = m }, formatNumber: function (h, m, v) { v = v || "en"; if (Ja[v]) return ea(h, m || "#,##0.##", new Ia(v)); throw "Unknown Culture Name"; }, formatDate: function (h, m, v) { v = v || "en"; if (Ja[v]) return za(h, m || "DD MMM YYYY", new Ia(v)); throw "Unknown Culture Name"; } }; "undefined" !== typeof module &&
            "undefined" !== typeof module.exports ? module.exports = Oa : "function" === typeof define && define.amd ? define([], function () { return Oa }) : (window.CanvasJS && window.//console && window.//////console.log("CanvasJS namespace already exists. If you are loading both chart and stockchart scripts, just load stockchart alone as it includes all chart features."), window.CanvasJS = window.CanvasJS ? window.CanvasJS : Oa); y = Oa.Chart = function () {
                function h(a, d) { return a.x - d.x } function m(a, d, c) {
                    d = d || {}; s(c) ? (this.predefinedThemes = ab, this.optionsName =
                        this.parent = this.index = null) : (this.parent = c.parent, this.index = c.index, this.predefinedThemes = c.predefinedThemes, this.optionsName = c.optionsName, this.stockChart = c.stockChart, this.panel = a, this.isOptionsInArray = c.isOptionsInArray); this.theme = s(d.theme) || s(this.predefinedThemes[d.theme]) ? "light1" : d.theme; m.base.constructor.call(this, "Chart", this.optionsName, d, this.index, this.parent); var b = this; this._containerId = a; this._objectsInitialized = !1; this.overlaidCanvasCtx = this.ctx = null; this._indexLabels = []; this._panTimerId =
                            0; this._lastTouchEventType = ""; this._lastTouchData = null; this.isAnimating = !1; this.renderCount = 0; this.disableToolTip = this.animatedRender = !1; this.canvasPool = new Ta; this.allDOMEventHandlers = []; this.panEnabled = !1; this._defaultCursor = "default"; this.plotArea = { canvas: null, ctx: null, x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 }; this._dataInRenderedOrder = []; (this.container = "string" === typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) ? (this.container.innerHTML = "", d = a = 0, a = this.options.width ?
                                this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width, d = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height, this.width = a, this.height = d, this.x1 = this.y1 = 0, this.x2 = this.width, this.y2 = this.height, this.selectedColorSet = "undefined" !== typeof ya[this.colorSet] ? ya[this.colorSet] : ya.colorSet1, this._canvasJSContainer = document.createElement("div"), this._canvasJSContainer.setAttribute("class", "canvasjs-chart-container"), this._canvasJSContainer.style.position =
                                "relative", this._canvasJSContainer.style.textAlign = "left", this._canvasJSContainer.style.cursor = "auto", this._canvasJSContainer.style.direction = "ltr", v || (this._canvasJSContainer.style.height = "0px"), this.container.appendChild(this._canvasJSContainer), this.canvas = sa(a, d), this._preRenderCanvas = sa(a, d), this.canvas.style.position = "absolute", this.canvas.style.WebkitUserSelect = "none", this.canvas.style.MozUserSelect = "none", this.canvas.style.msUserSelect = "none", this.canvas.style.userSelect = "none", this.canvas.getContext &&
                                (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", Aa(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext("2d"), this._preRenderCtx.textBaseline = "top", Aa(this._preRenderCtx), v ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = sa(a, d), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")),
                                    this.overlaidCanvas = sa(a, d), this.overlaidCanvas.style.position = "absolute", this.overlaidCanvas.style.webkitTapHighlightColor = "transparent", this.overlaidCanvas.style.WebkitUserSelect = "none", this.overlaidCanvas.style.MozUserSelect = "none", this.overlaidCanvas.style.msUserSelect = "none", this.overlaidCanvas.style.userSelect = "none", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline =
                                        "top", Aa(this.overlaidCanvasCtx)), this._eventManager = new da(this), this.windowResizeHandler = J(window, "resize", function () { b._updateSize() && b.render() }, this.allDOMEventHandlers), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), this._toolBar.style.cssText = "position: absolute; right: 1px; top: 1px;", this._canvasJSContainer.appendChild(this._toolBar), this.bounds = { x1: 0, y1: 0, x2: this.width, y2: this.height }, J(this.overlaidCanvas, "click", function (a) { b._mouseEventHandler(a) },
                                            this.allDOMEventHandlers), J(this.overlaidCanvas, "mousemove", function (a) { b._mouseEventHandler(a) }, this.allDOMEventHandlers), J(this.overlaidCanvas, "mouseup", function (a) { b._mouseEventHandler(a) }, this.allDOMEventHandlers), J(this.overlaidCanvas, "mousedown", function (a) { b._mouseEventHandler(a); ta(b._dropdownMenu) }, this.allDOMEventHandlers), J(this.overlaidCanvas, "mouseout", function (a) { b._mouseEventHandler(a) }, this.allDOMEventHandlers), J(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" :
                                                "touchstart", function (a) { b._touchEventHandler(a) }, this.allDOMEventHandlers), J(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function (a) { b._touchEventHandler(a) }, this.allDOMEventHandlers), J(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", function (a) { b._touchEventHandler(a) }, this.allDOMEventHandlers), J(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", function (a) { b._touchEventHandler(a) }, this.allDOMEventHandlers),
                                    this.toolTip = new Y(this, this.options.toolTip), this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = { axisX: [], axisX2: [], axisY: [], axisY2: [] })) : window.//console && window.//////console.log('CanvasJS Error: Chart Container with id "' + this._containerId + '" was not found')
                } function w(a, d) {
                    for (var c = [], b, e = 0; e < a.length; e++)if (0 == e) c.push(a[0]); else {
                        var f, l, u; u = e - 1; f = 0 === u ? 0 : u - 1; l = u === a.length - 1 ? u : u + 1; b = Math.abs((a[l].x - a[f].x) / (0 === a[l].x - a[u].x ? 0.01 : a[l].x - a[u].x)) * (d - 1) /
                            2 + 1; var A = (a[l].x - a[f].x) / b; b = (a[l].y - a[f].y) / b; c[c.length] = a[u].x > a[f].x && 0 < A || a[u].x < a[f].x && 0 > A ? { x: a[u].x + A / 3, y: a[u].y + b / 3 } : { x: a[u].x, y: a[u].y + b / 9 }; u = e; f = 0 === u ? 0 : u - 1; l = u === a.length - 1 ? u : u + 1; b = Math.abs((a[l].x - a[f].x) / (0 === a[u].x - a[f].x ? 0.01 : a[u].x - a[f].x)) * (d - 1) / 2 + 1; A = (a[l].x - a[f].x) / b; b = (a[l].y - a[f].y) / b; c[c.length] = a[u].x > a[f].x && 0 < A || a[u].x < a[f].x && 0 > A ? { x: a[u].x - A / 3, y: a[u].y - b / 3 } : { x: a[u].x, y: a[u].y - b / 9 }; c[c.length] = a[e]
                    } return c
                } function y(a, d, c, b, e, f, l, u, A, k) {
                    var n = 0; k ? (l.color = f, u.color = f) :
                        k = 1; n = A ? Math.abs(e - c) : Math.abs(b - d); n = 0 < l.trimLength ? Math.abs(n * l.trimLength / 100) : Math.abs(n - l.length); A ? (c += n / 2, e -= n / 2) : (d += n / 2, b -= n / 2); var n = 1 === Math.round(l.thickness) % 2 ? 0.5 : 0, p = 1 === Math.round(u.thickness) % 2 ? 0.5 : 0; a.save(); a.globalAlpha = k; a.strokeStyle = u.color || f; a.lineWidth = u.thickness || 2; a.setLineDash && a.setLineDash(N(u.dashType, u.thickness)); a.beginPath(); A && 0 < u.thickness ? (a.moveTo(b - l.thickness / 2, Math.round((c + e) / 2) - p), a.lineTo(d + l.thickness / 2, Math.round((c + e) / 2) - p)) : 0 < u.thickness && (a.moveTo(Math.round((d +
                            b) / 2) - p, c + l.thickness / 2), a.lineTo(Math.round((d + b) / 2) - p, e - l.thickness / 2)); a.stroke(); a.strokeStyle = l.color || f; a.lineWidth = l.thickness || 2; a.setLineDash && a.setLineDash(N(l.dashType, l.thickness)); a.beginPath(); A && 0 < l.thickness ? (a.moveTo(b - n, c), a.lineTo(b - n, e), a.moveTo(d + n, c), a.lineTo(d + n, e)) : 0 < l.thickness && (a.moveTo(d, c + n), a.lineTo(b, c + n), a.moveTo(d, e - n), a.lineTo(b, e - n)); a.stroke(); a.restore()
                } function F(a, d) {
                    F.base.constructor.call(this, "Legend", "legend", d, null, a); this.chart = a; this.canvas = a.canvas;
                    this.ctx = this.chart.ctx; this.ghostCtx = this.chart._eventManager.ghostCtx; this.items = []; this.optionsName = "legend"; this.height = this.width = 0; this.orientation = null; this.dataSeries = []; this.bounds = { x1: null, y1: null, x2: null, y2: null }; "undefined" === typeof this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)); this.lineHeight = Wa(this.fontFamily, this.fontSize, this.fontWeight); this.horizontalSpacing = this.fontSize
                } function H(a, d, c, b) {
                    H.base.constructor.call(this, "DataSeries", "data", d, c,
                        a); this.chart = a; this.canvas = a.canvas; this._ctx = a.canvas.ctx; this.index = c; this.noDataPointsInPlotArea = 0; this.id = b; this.chart._eventManager.objectMap[b] = { id: b, objectType: "dataSeries", dataSeriesIndex: c }; a = d.dataPoints ? d.dataPoints.length : 0; this.dataPointEOs = []; for (d = 0; d < a; d++)this.dataPointEOs[d] = {}; this.dataPointIds = []; this.plotUnit = []; this.axisY = this.axisX = null; this.optionsName = "data"; this.isOptionsInArray = !0; null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = 0.7 : this.fillOpacity =
                            1); this.axisPlacement = this.getDefaultAxisPlacement(); "undefined" === typeof this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize))
                } function D(a, d, c, b, e, f) {
                    D.base.constructor.call(this, "Axis", d, c, b, a); this.chart = a; this.canvas = a.canvas; this.ctx = a.ctx; this.intervalStartPosition = this.maxHeight = this.maxWidth = 0; this.labels = []; this.dataSeries = []; this._stripLineLabels = this._ticks = this._labels = null; this.dataInfo = {
                        min: Infinity, max: -Infinity, viewPortMin: Infinity,
                        viewPortMax: -Infinity, minDiff: Infinity
                    }; this.isOptionsInArray = !0; "axisX" === e ? ("left" === f || "bottom" === f ? (this.optionsName = "axisX", s(this.chart.sessionVariables.axisX[b]) && (this.chart.sessionVariables.axisX[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisX[b]) : (this.optionsName = "axisX2", s(this.chart.sessionVariables.axisX2[b]) && (this.chart.sessionVariables.axisX2[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[b]), this.options.interval || (this.intervalType = null)) : "left" ===
                        f || "bottom" === f ? (this.optionsName = "axisY", s(this.chart.sessionVariables.axisY[b]) && (this.chart.sessionVariables.axisY[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisY[b]) : (this.optionsName = "axisY2", s(this.chart.sessionVariables.axisY2[b]) && (this.chart.sessionVariables.axisY2[b] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[b]); "undefined" === typeof this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize)); "undefined" === typeof this.options.labelFontSize &&
                            (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize)); this.type = e; "axisX" !== e || c && "undefined" !== typeof c.gridThickness || (this.gridThickness = 0); this._position = f; this.lineCoordinates = { x1: null, y1: null, x2: null, y2: null, width: null }; this.labelAngle = (this.labelAngle % 360 + 360) % 360; 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360); this.options.scaleBreaks && (this.scaleBreaks = new Z(this.chart, this.options.scaleBreaks, ++this.chart._eventManager.lastObjectId,
                                this)); this.stripLines = []; if (this.options.stripLines && 0 < this.options.stripLines.length) for (a = 0; a < this.options.stripLines.length; a++)this.stripLines.push(new M(this.chart, this.options.stripLines[a], a, ++this.chart._eventManager.lastObjectId, this)); this.options.crosshair && (this.crosshair = new $(this.chart, this.options.crosshair, this)); this._titleTextBlock = null; this.hasOptionChanged("viewportMinimum") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum =
                                    null); this.hasOptionChanged("viewportMinimum") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum; this.hasOptionChanged("viewportMaximum") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null); this.hasOptionChanged("viewportMaximum") || isNaN(this.sessionVariables.newViewportMaximum) || null ===
                                        this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum; null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum)); null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum)); this.trackChanges("viewportMinimum"); this.trackChanges("viewportMaximum")
                } function Z(a, d, c, b) {
                    Z.base.constructor.call(this,
                        "ScaleBreaks", "scaleBreaks", d, null, b); this.id = c; this.chart = a; this.ctx = this.chart.ctx; this.axis = b; this.optionsName = "scaleBreaks"; this.isOptionsInArray = !1; this._appliedBreaks = []; this.customBreaks = []; this.autoBreaks = []; "string" === typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.spacing && (this.spacing = 8); this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5)); if (this.options.customBreaks &&
                            0 < this.options.customBreaks.length) {
                                for (a = 0; a < this.options.customBreaks.length; a++)this.customBreaks.push(new U(this.chart, "customBreaks", this.options.customBreaks[a], a, ++this.chart._eventManager.lastObjectId, this)), "number" === typeof this.customBreaks[a].startValue && ("number" === typeof this.customBreaks[a].endValue && this.customBreaks[a].endValue !== this.customBreaks[a].startValue) && this._appliedBreaks.push(this.customBreaks[a]); this._appliedBreaks.sort(function (a, b) { return a.startValue - b.startValue });
                        for (a = 0; a < this._appliedBreaks.length - 1; a++)this._appliedBreaks[a].endValue >= this._appliedBreaks[a + 1].startValue && (this._appliedBreaks[a].endValue = Math.max(this._appliedBreaks[a].endValue, this._appliedBreaks[a + 1].endValue), window.//console && window.//////console.log("CanvasJS Error: Breaks " + a + " and " + (a + 1) + " are overlapping."), this._appliedBreaks.splice(a, 2), a--)
                    }
                } function U(a, d, c, b, e, f) {
                    U.base.constructor.call(this, "Break", d, c, b, f); this.id = e; this.chart = a; this.ctx = this.chart.ctx; this.scaleBreaks = f; this.optionsName =
                        d; this.isOptionsInArray = !0; this.type = c.type ? this.type : f.type; this.fillOpacity = s(c.fillOpacity) ? f.fillOpacity : this.fillOpacity; this.lineThickness = s(c.lineThickness) ? f.lineThickness : this.lineThickness; this.color = c.color ? this.color : f.color; this.lineColor = c.lineColor ? this.lineColor : f.lineColor; this.lineDashType = c.lineDashType ? this.lineDashType : f.lineDashType; !s(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime()); !s(this.endValue) && this.endValue.getTime && (this.endValue =
                            this.endValue.getTime()); "number" === typeof this.startValue && ("number" === typeof this.endValue && this.endValue < this.startValue) && (a = this.startValue, this.startValue = this.endValue, this.endValue = a); this.spacing = "undefined" === typeof c.spacing ? f.spacing : c.spacing; "string" === typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" !== typeof this.options.spacing && (this.spacing = f.spacing); this.size = f.parent.logarithmic ?
                                1 : 0
                } function M(a, d, c, b, e) {
                    M.base.constructor.call(this, "StripLine", "stripLines", d, c, e); this.id = b; this.chart = a; this.ctx = this.chart.ctx; this.label = this.label; this.axis = e; this.optionsName = "stripLines"; this.isOptionsInArray = !0; this._thicknessType = "pixel"; null !== this.startValue && null !== this.endValue && (this.value = e.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() :
                        this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null)
                } function $(a, d, c) { $.base.constructor.call(this, "Crosshair", "crosshair", d, null, c); this.chart = a; this.ctx = this.chart.ctx; this.axis = c; this.optionsName = "crosshair"; this._thicknessType = "pixel" } function Y(a, d) {
                    Y.base.constructor.call(this, "ToolTip", "toolTip", d, null, a); this.chart = a; this.canvas = a.canvas; this.ctx = this.chart.ctx; this.currentDataPointIndex = this.currentSeriesIndex = -1; this._prevY = this._prevX =
                        NaN; this.containerTransitionDuration = 0.1; this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration); this.optionsName = "toolTip"; this._initialize()
                } function da(a) { this.chart = a; this.lastObjectId = 0; this.objectMap = []; this.rectangularRegionEventSubscriptions = []; this.previousDataPointEventObject = null; this.ghostCanvas = sa(this.chart.width, this.chart.height); this.ghostCtx = this.ghostCanvas.getContext("2d"); this.mouseoveredObjectMaps = [] } function ha(a) {
                    this.chart = a; this.ctx = this.chart.plotArea.ctx;
                    this.animations = []; this.animationRequestId = null
                } na(m, V); m.prototype.destroy = function () {
                    var a = this.allDOMEventHandlers; this._animator && this._animator.cancelAllAnimations(); this._panTimerId && clearTimeout(this._panTimerId); for (var d = 0; d < a.length; d++) { var c = a[d][0], b = a[d][1], e = a[d][2], f = a[d][3], f = f || !1; c.removeEventListener ? c.removeEventListener(b, e, f) : c.detachEvent && c.detachEvent("on" + b, e) } this.allDOMEventHandlers = []; for (this.removeAllEventListeners(); this._canvasJSContainer && this._canvasJSContainer.hasChildNodes();)this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild);
                    for (; this.container && this.container.hasChildNodes();)this.container.removeChild(this.container.lastChild); for (; this._dropdownMenu && this._dropdownMenu.hasChildNodes();)this._dropdownMenu.removeChild(this._dropdownMenu.lastChild); this.overlaidCanvas = this.canvas = this.container = this._canvasJSContainer = null; this._toolBar = this._dropdownMenu = this._menuButton = this._resetButton = this._zoomButton = this._breaksCanvas = this._preRenderCanvas = this.toolTip.container = null
                }; m.prototype._updateOptions = function () {
                    var a =
                        this; this.updateOption("width"); this.updateOption("height"); this.updateOption("dataPointWidth"); this.updateOption("dataPointMinWidth"); this.updateOption("dataPointMaxWidth"); this.updateOption("interactivityEnabled"); this.updateOption("theme"); this.updateOption("colorSet") && (this.selectedColorSet = "undefined" !== typeof ya[this.colorSet] ? ya[this.colorSet] : ya.colorSet1); this.updateOption("backgroundColor"); this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)"); this.updateOption("culture"); this._cultureInfo =
                            new Ia(this.options.culture); this.updateOption("animationEnabled"); this.animationEnabled = this.animationEnabled && v; this.updateOption("animationDuration"); this.updateOption("rangeChanging"); this.updateOption("rangeChanged"); this.updateOption("exportEnabled"); this.updateOption("exportFileName"); this.updateOption("zoomType"); if (this.options.zoomEnabled || this.panEnabled) {
                                if (!this._zoomButton) {
                                    var d = !1; ta(this._zoomButton = document.createElement("button")); ua(this, this._zoomButton, "pan"); this._toolBar.appendChild(this._zoomButton);
                                    this._zoomButton.style.borderRight = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor; J(this._zoomButton, "touchstart", function (a) { d = !0 }, this.allDOMEventHandlers); J(this._zoomButton, "click", function () { a.zoomEnabled ? (a.zoomEnabled = !1, a.panEnabled = !0, ua(a, a._zoomButton, "zoom")) : (a.zoomEnabled = !0, a.panEnabled = !1, ua(a, a._zoomButton, "pan")); a.render() }, this.allDOMEventHandlers); J(this._zoomButton, "mouseover", function () {
                                        d ? d = !1 : (oa(a._zoomButton, {
                                            backgroundColor: a.toolbar.backgroundColorOnHover,
                                            color: a.toolbar.fontColorOnHover, transition: "0.4s", WebkitTransition: "0.4s"
                                        }), 0 >= navigator.userAgent.search("MSIE") && oa(a._zoomButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" }))
                                    }, this.allDOMEventHandlers); J(this._zoomButton, "mouseout", function () { d || (oa(a._zoomButton, { backgroundColor: a.toolbar.backgroundColor, color: a.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && oa(a._zoomButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" })) },
                                        this.allDOMEventHandlers)
                                } this._resetButton || (d = !1, ta(this._resetButton = document.createElement("button")), ua(this, this._resetButton, "reset"), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + "px solid " + this.toolbar.borderColor, this._toolBar.appendChild(this._resetButton), J(this._resetButton, "touchstart", function (a) { d = !0 }, this.allDOMEventHandlers), J(this._resetButton, "click", function () {
                                    a.toolTip.hide(); a.toolTip.dispatchEvent("hidden", { chart: a, toolTip: a.toolTip },
                                        a.toolTip); a.zoomEnabled || a.panEnabled ? (a.zoomEnabled = !0, a.panEnabled = !1, ua(a, a._zoomButton, "pan"), a._defaultCursor = "default", a.overlaidCanvas.style.cursor = a._defaultCursor) : (a.zoomEnabled = !1, a.panEnabled = !1); if (a.sessionVariables.axisX) for (var b = 0; b < a.sessionVariables.axisX.length; b++)a.sessionVariables.axisX[b].newViewportMinimum = null, a.sessionVariables.axisX[b].newViewportMaximum = null; if (a.sessionVariables.axisX2) for (b = 0; b < a.sessionVariables.axisX2.length; b++)a.sessionVariables.axisX2[b].newViewportMinimum =
                                            null, a.sessionVariables.axisX2[b].newViewportMaximum = null; if (a.sessionVariables.axisY) for (b = 0; b < a.sessionVariables.axisY.length; b++)a.sessionVariables.axisY[b].newViewportMinimum = null, a.sessionVariables.axisY[b].newViewportMaximum = null; if (a.sessionVariables.axisY2) for (b = 0; b < a.sessionVariables.axisY2.length; b++)a.sessionVariables.axisY2[b].newViewportMinimum = null, a.sessionVariables.axisY2[b].newViewportMaximum = null; a.resetOverlayedCanvas(); ta(a._zoomButton, a._resetButton); a.stockChart && (a.stockChart._rangeEventParameter =
                                                { stockChart: a.stockChart, source: "chart", index: a.stockChart.charts.indexOf(a), minimum: null, maximum: null }); a._dispatchRangeEvent("rangeChanging", "reset"); a.stockChart && (a.stockChart._rangeEventParameter.type = "rangeChanging", a.stockChart.dispatchEvent("rangeChanging", a.stockChart._rangeEventParameter, a.stockChart)); a.render(); a.syncCharts && a.syncCharts(null, null); a._dispatchRangeEvent("rangeChanged", "reset"); a.stockChart && (a.stockChart._rangeEventParameter.type = "rangeChanged", a.stockChart.dispatchEvent("rangeChanged",
                                                    a.stockChart._rangeEventParameter, a.stockChart))
                                }, this.allDOMEventHandlers), J(this._resetButton, "mouseover", function () { d || (oa(a._resetButton, { backgroundColor: a.toolbar.backgroundColorOnHover, color: a.toolbar.hoverFfontColorOnHoverontColor, transition: "0.4s", WebkitTransition: "0.4s" }), 0 >= navigator.userAgent.search("MSIE") && oa(a._resetButton.childNodes[0], { WebkitFilter: "invert(100%)", filter: "invert(100%)" })) }, this.allDOMEventHandlers), J(this._resetButton, "mouseout", function () {
                                    d || (oa(a._resetButton, {
                                        backgroundColor: a.toolbar.backgroundColor,
                                        color: a.toolbar.fontColor, transition: "0.4s", WebkitTransition: "0.4s"
                                    }), 0 >= navigator.userAgent.search("MSIE") && oa(a._resetButton.childNodes[0], { WebkitFilter: "invert(0%)", filter: "invert(0%)" }))
                                }, this.allDOMEventHandlers), this.overlaidCanvas.style.cursor = a._defaultCursor); this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute("state") === a._cultureInfo.zoomText ? (this.panEnabled = !0, this.zoomEnabled = !1) : (this.zoomEnabled = !0, this.panEnabled = !1), Ka(a._zoomButton, a._resetButton)) :
                                    (this.zoomEnabled = !0, this.panEnabled = !1))
                            } else this.panEnabled = this.zoomEnabled = !1; gb(this); "none" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? ua(a, a._zoomButton, "zoom") : ua(a, a._zoomButton, "pan"), a._resetButton.getAttribute("state") !== a._cultureInfo.resetText && ua(a, a._resetButton, "reset")); this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip); for (var c in this.toolTip.options) this.toolTip.options.hasOwnProperty(c) && this.toolTip.updateOption(c)
                };
                m.prototype._updateSize = function () {
                    var a; a = [this.canvas, this.overlaidCanvas, this._eventManager.ghostCanvas]; var d = 0, c = 0; this.options.width ? d = this.width : this.width = d = 0 < this.container.clientWidth ? this.container.clientWidth : this.width; this.options.height ? c = this.height : this.height = c = 0 < this.container.clientHeight ? this.container.clientHeight : this.height; if (this.canvas.width !== d * ga || this.canvas.height !== c * ga) {
                        for (var b = 0; b < a.length; b++)La(a[b], d, c); this.bounds = {
                            x1: 0, y1: 0, x2: this.width, y2: this.height, width: this.width,
                            height: this.height
                        }; a = !0
                    } else a = !1; return a
                }; m.prototype._initialize = function () {
                    this.isNavigator = s(this.parent) || s(this.parent._defaultsKey) || "Navigator" !== this.parent._defaultsKey ? !1 : !0; this.toolbar = new Sa(this, this.options.toolbar); this._animator ? this._animator.cancelAllAnimations() : this._animator = new ha(this); this.removeAllEventListeners(); this.disableToolTip = !1; this._axes = []; this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null; this._updateOptions(); this.animatedRender = v && this.animationEnabled &&
                        0 === this.renderCount; this._updateSize(); this.clearCanvas(); this.ctx.beginPath(); this.axisX = []; this.axisX2 = []; this.axisY = []; this.axisY2 = []; this._indexLabels = []; this._dataInRenderedOrder = []; this._events = []; this._eventManager && this._eventManager.reset(); this.plotInfo = { axisPlacement: null, plotTypes: [] }; this.layoutManager = new Ca(0, 0, this.width, this.height, this.isNavigator ? 0 : 2); this.plotArea.layoutManager && this.plotArea.layoutManager.reset(); this.data = []; this.title = null; this.subtitles = []; var a = 0, d = null;
                    if (this.options.data) {
                        for (var c = 0; c < this.options.data.length; c++)if (a++, !this.options.data[c].type || 0 <= m._supportedChartTypes.indexOf(this.options.data[c].type)) {
                            var b = new H(this, this.options.data[c], a - 1, ++this._eventManager.lastObjectId); "error" === b.type && (b.linkedDataSeriesIndex = s(this.options.data[c].linkedDataSeriesIndex) ? c - 1 : this.options.data[c].linkedDataSeriesIndex, 0 > b.linkedDataSeriesIndex || b.linkedDataSeriesIndex >= this.options.data.length || "number" !== typeof b.linkedDataSeriesIndex || "error" ===
                                this.options.data[b.linkedDataSeriesIndex].type) && (b.linkedDataSeriesIndex = null); null === b.name && (b.name = "DataSeries " + a); null === b.color ? 1 < this.options.data.length ? (b._colorSet = [this.selectedColorSet[b.index % this.selectedColorSet.length]], b.color = this.selectedColorSet[b.index % this.selectedColorSet.length]) : b._colorSet = "line" === b.type || "stepLine" === b.type || "spline" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "stackedArea" === b.type || "stackedArea100" === b.type || "rangeArea" ===
                                    b.type || "rangeSplineArea" === b.type || "candlestick" === b.type || "ohlc" === b.type || "waterfall" === b.type || "boxAndWhisker" === b.type ? [this.selectedColorSet[0]] : this.selectedColorSet : b._colorSet = [b.color]; null === b.markerSize && (("line" === b.type || "stepLine" === b.type || "spline" === b.type || 0 <= b.type.toLowerCase().indexOf("area")) && b.dataPoints && b.dataPoints.length < this.width / 16 || "scatter" === b.type) && (b.markerSize = 8); "bubble" !== b.type && "scatter" !== b.type || !b.dataPoints || (b.dataPoints.some ? b.dataPoints.some(function (a) { return a.x }) &&
                                        b.dataPoints.sort(h) : b.dataPoints.sort(h)); this.data.push(b); var e = b.axisPlacement, d = d || e, f; "normal" === e ? "xySwapped" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with bar chart' : "none" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "normal") : "xySwapped" === e ? "normal" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with line, area, column or pie chart' : "none" === this.plotInfo.axisPlacement ?
                                            f = 'You cannot combine "' + b.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "xySwapped") : "none" === e ? "normal" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with line, area, column or bar chart' : "xySwapped" === this.plotInfo.axisPlacement ? f = 'You cannot combine "' + b.type + '" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "none") : null === e && "none" === this.plotInfo.axisPlacement && (f = 'You cannot combine "' + b.type + '" with pie chart');
                            if (f && window.//console) { window.//////console.log(f); return }
                        } for (c = 0; c < this.data.length; c++) { if ("none" == d && "error" === this.data[c].type && window.//console) { window.//////console.log('You cannot combine "' + b.type + '" with error chart'); return } "error" === this.data[c].type && (this.data[c].axisPlacement = this.plotInfo.axisPlacement = d || "normal", this.data[c]._linkedSeries = null === this.data[c].linkedDataSeriesIndex ? null : this.data[this.data[c].linkedDataSeriesIndex]) }
                    } this._objectsInitialized = !0; this._plotAreaElements = []
                }; m._supportedChartTypes =
                    Ba("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall".split(" ")); m.prototype.setLayout = function () {
                        for (var a = this._plotAreaElements, d = 0; d < this.data.length; d++)if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) {
                            if (!this.data[d].axisYType ||
                                "primary" === this.data[d].axisYType) if (this.options.axisY && 0 < this.options.axisY.length) {
                                    if (!this.axisY.length) for (var c = 0; c < this.options.axisY.length; c++)"normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[c] = new D(this, "axisY", this.options.axisY[c], c, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[c] = new D(this, "axisY", this.options.axisY[c], c, "axisY", "bottom")); this.data[d].axisY = this.axisY[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY.length ?
                                        this.data[d].axisYIndex : 0]; this.axisY[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY.length ? this.data[d].axisYIndex : 0].dataSeries.push(this.data[d])
                                } else this.axisY.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new D(this, "axisY", this.options.axisY, 0, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new D(this, "axisY", this.options.axisY, 0, "axisY", "bottom"))), this.data[d].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[d]);
                            if ("secondary" === this.data[d].axisYType) if (this.options.axisY2 && 0 < this.options.axisY2.length) {
                                if (!this.axisY2.length) for (c = 0; c < this.options.axisY2.length; c++)"normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[c] = new D(this, "axisY2", this.options.axisY2[c], c, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[c] = new D(this, "axisY2", this.options.axisY2[c], c, "axisY", "top")); this.data[d].axisY = this.axisY2[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex <
                                    this.axisY2.length ? this.data[d].axisYIndex : 0]; this.axisY2[0 <= this.data[d].axisYIndex && this.data[d].axisYIndex < this.axisY2.length ? this.data[d].axisYIndex : 0].dataSeries.push(this.data[d])
                            } else this.axisY2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[0] = new D(this, "axisY2", this.options.axisY2, 0, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new D(this, "axisY2", this.options.axisY2, 0, "axisY", "top"))), this.data[d].axisY = this.axisY2[0],
                                this.axisY2[0].dataSeries.push(this.data[d]); if (!this.data[d].axisXType || "primary" === this.data[d].axisXType) if (this.options.axisX && 0 < this.options.axisX.length) {
                                    if (!this.axisX.length) for (c = 0; c < this.options.axisX.length; c++)"normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[c] = new D(this, "axisX", this.options.axisX[c], c, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[c] = new D(this, "axisX", this.options.axisX[c], c, "axisX", "left")); this.data[d].axisX =
                                        this.axisX[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX.length ? this.data[d].axisXIndex : 0]; this.axisX[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX.length ? this.data[d].axisXIndex : 0].dataSeries.push(this.data[d])
                                } else this.axisX.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[0] = new D(this, "axisX", this.options.axisX, 0, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new D(this, "axisX", this.options.axisX,
                                    0, "axisX", "left"))), this.data[d].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[d]); if ("secondary" === this.data[d].axisXType) if (this.options.axisX2 && 0 < this.options.axisX2.length) {
                                        if (!this.axisX2.length) for (c = 0; c < this.options.axisX2.length; c++)"normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[c] = new D(this, "axisX2", this.options.axisX2[c], c, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[c] = new D(this, "axisX2", this.options.axisX2[c],
                                            c, "axisX", "right")); this.data[d].axisX = this.axisX2[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX2.length ? this.data[d].axisXIndex : 0]; this.axisX2[0 <= this.data[d].axisXIndex && this.data[d].axisXIndex < this.axisX2.length ? this.data[d].axisXIndex : 0].dataSeries.push(this.data[d])
                                    } else this.axisX2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new D(this, "axisX2", this.options.axisX2, 0, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] =
                                        new D(this, "axisX2", this.options.axisX2, 0, "axisX", "right"))), this.data[d].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[d])
                        } if (this.axisY) { for (c = 1; c < this.axisY.length; c++)"undefined" === typeof this.axisY[c].options.gridThickness && (this.axisY[c].gridThickness = 0); for (c = 0; c < this.axisY.length - 1; c++)"undefined" === typeof this.axisY[c].options.margin && (this.axisY[c].margin = 10) } if (this.axisY2) {
                            for (c = 1; c < this.axisY2.length; c++)"undefined" === typeof this.axisY2[c].options.gridThickness && (this.axisY2[c].gridThickness =
                                0); for (c = 0; c < this.axisY2.length - 1; c++)"undefined" === typeof this.axisY2[c].options.margin && (this.axisY2[c].margin = 10)
                        } this.axisY && 0 < this.axisY.length && (this.axisY2 && 0 < this.axisY2.length) && (0 < this.axisY[0].gridThickness && "undefined" === typeof this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness = 0 : 0 < this.axisY2[0].gridThickness && "undefined" === typeof this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0)); if (this.axisX) for (c = 0; c < this.axisX.length; c++)"undefined" === typeof this.axisX[c].options.gridThickness &&
                            (this.axisX[c].gridThickness = 0); if (this.axisX2) for (c = 0; c < this.axisX2.length; c++)"undefined" === typeof this.axisX2[c].options.gridThickness && (this.axisX2[c].gridThickness = 0); this.axisX && 0 < this.axisX.length && (this.axisX2 && 0 < this.axisX2.length) && (0 < this.axisX[0].gridThickness && "undefined" === typeof this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && "undefined" === typeof this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0)); c = !1; if (0 < this._axes.length &&
                                this.options.zoomEnabled && (this.zoomEnabled || this.panEnabled)) for (d = 0; d < this._axes.length; d++)if (null !== this._axes[d].viewportMinimum || null !== this._axes[d].viewportMaximum) { c = !0; break } c ? (Ka(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor, this._zoomButton.style.borderRight = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness :
                                    0) + "px solid " + this.toolbar.borderColor) : (ta(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + "px solid transparent", this.options.zoomEnabled && (this.zoomEnabled = !0, this.panEnabled = !1)); eb(this); this._processData(); this.options.title && (this.title = new xa(this, this.options.title), this.title.dockInsidePlotArea ? a.push(this.title) : this.title.setLayout()); if (this.options.subtitles) for (d = 0; d < this.options.subtitles.length; d++)c = new Ha(this, this.options.subtitles[d],
                                        d), this.subtitles.push(c), c.dockInsidePlotArea ? a.push(c) : c.setLayout(); this.legend = new F(this, this.options.legend); for (d = 0; d < this.data.length; d++)(this.data[d].showInLegend || "pie" === this.data[d].type || "doughnut" === this.data[d].type || "funnel" === this.data[d].type || "pyramid" === this.data[d].type) && this.legend.dataSeries.push(this.data[d]); this.legend.dockInsidePlotArea ? a.push(this.legend) : this.legend.setLayout(); for (d = 0; d < this._axes.length; d++)if (this._axes[d].scaleBreaks && this._axes[d].scaleBreaks._appliedBreaks.length) {
                                            v ?
                                                (this._breaksCanvas = sa(this.width, this.height, !0), this._breaksCanvasCtx = this._breaksCanvas.getContext("2d")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx); break
                                        } this._preRenderCanvas = sa(this.width, this.height); this._preRenderCtx = this._preRenderCanvas.getContext("2d"); "normal" !== this.plotInfo.axisPlacement && "xySwapped" !== this.plotInfo.axisPlacement || D.setLayout(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace())
                    }; m.prototype.renderElements =
                        function () {
                            var a = this._plotAreaElements; this.title && !this.title.dockInsidePlotArea && this.title.render(); for (var d = 0; d < this.subtitles.length; d++)this.subtitles[d].dockInsidePlotArea || this.subtitles[d].render(); this.legend.dockInsidePlotArea || this.legend.render(); if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) D.render(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement); else if ("none" === this.plotInfo.axisPlacement) this.preparePlotArea(); else return;
                            for (d = 0; d < a.length; d++)a[d].setLayout(), a[d].render(); var c = []; if (this.animatedRender) { var b = sa(this.width, this.height); b.getContext("2d").drawImage(this.canvas, 0, 0, this.width, this.height) } hb(this); var a = this.ctx.miterLimit, e; this.ctx.miterLimit = 3; v && this._breaksCanvas && (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = "source-atop", this._breaksCanvasCtx.drawImage(this._preRenderCanvas,
                                0, 0, this.width, this.height), this._preRenderCtx.clearRect(0, 0, this.width, this.height)); for (d = 0; d < this.plotInfo.plotTypes.length; d++)for (var f = this.plotInfo.plotTypes[d], l = 0; l < f.plotUnits.length; l++) {
                                    var u = f.plotUnits[l], A = null; u.targetCanvas = null; this.animatedRender && (u.targetCanvas = sa(this.width, this.height), u.targetCanvasCtx = u.targetCanvas.getContext("2d"), e = u.targetCanvasCtx.miterLimit, u.targetCanvasCtx.miterLimit = 3); "line" === u.type ? A = this.renderLine(u) : "stepLine" === u.type ? A = this.renderStepLine(u) :
                                        "spline" === u.type ? A = this.renderSpline(u) : "column" === u.type ? A = this.renderColumn(u) : "bar" === u.type ? A = this.renderBar(u) : "area" === u.type ? A = this.renderArea(u) : "stepArea" === u.type ? A = this.renderStepArea(u) : "splineArea" === u.type ? A = this.renderSplineArea(u) : "stackedColumn" === u.type ? A = this.renderStackedColumn(u) : "stackedColumn100" === u.type ? A = this.renderStackedColumn100(u) : "stackedBar" === u.type ? A = this.renderStackedBar(u) : "stackedBar100" === u.type ? A = this.renderStackedBar100(u) : "stackedArea" === u.type ? A = this.renderStackedArea(u) :
                                            "stackedArea100" === u.type ? A = this.renderStackedArea100(u) : "bubble" === u.type ? A = A = this.renderBubble(u) : "scatter" === u.type ? A = this.renderScatter(u) : "pie" === u.type ? this.renderPie(u) : "doughnut" === u.type ? this.renderPie(u) : "funnel" === u.type ? A = this.renderFunnel(u) : "pyramid" === u.type ? A = this.renderFunnel(u) : "candlestick" === u.type ? A = this.renderCandlestick(u) : "ohlc" === u.type ? A = this.renderCandlestick(u) : "rangeColumn" === u.type ? A = this.renderRangeColumn(u) : "error" === u.type ? A = this.renderError(u) : "rangeBar" === u.type ?
                                                A = this.renderRangeBar(u) : "rangeArea" === u.type ? A = this.renderRangeArea(u) : "rangeSplineArea" === u.type ? A = this.renderRangeSplineArea(u) : "waterfall" === u.type ? A = this.renderWaterfall(u) : "boxAndWhisker" === u.type && (A = this.renderBoxAndWhisker(u)); for (var k = 0; k < u.dataSeriesIndexes.length; k++)this._dataInRenderedOrder.push(this.data[u.dataSeriesIndexes[k]]); this.animatedRender && (u.targetCanvasCtx.miterLimit = e, A && c.push(A))
                                } this.ctx.miterLimit = a; this.animatedRender && this._breaksCanvasCtx && c.push({
                                    source: this._breaksCanvasCtx,
                                    dest: this.plotArea.ctx, animationCallback: L.fadeInAnimation, easingFunction: L.easing.easeInQuad, animationBase: 0, startTimePercent: 0.7
                                }); this.animatedRender && 0 < this._indexLabels.length && (e = sa(this.width, this.height).getContext("2d"), c.push(this.renderIndexLabels(e))); var n = this; if (0 < c.length) n.disableToolTip = !0, n._animator.animate(200, n.animationDuration, function (a) {
                                    n.ctx.clearRect(0, 0, n.width, n.height); n.ctx.drawImage(b, 0, 0, Math.floor(n.width * ga), Math.floor(n.height * ga), 0, 0, n.width, n.height); for (var e =
                                        0; e < c.length; e++)A = c[e], 1 > a && "undefined" !== typeof A.startTimePercent ? a >= A.startTimePercent && A.animationCallback(A.easingFunction(a - A.startTimePercent, 0, 1, 1 - A.startTimePercent), A) : A.animationCallback(A.easingFunction(a, 0, 1, 1), A); n.dispatchEvent("dataAnimationIterationEnd", { chart: n })
                                }, function () {
                                    c = []; for (var a = 0; a < n.plotInfo.plotTypes.length; a++)for (var e = n.plotInfo.plotTypes[a], d = 0; d < e.plotUnits.length; d++)e.plotUnits[d].targetCanvas = null; b = null; n.disableToolTip = !1; n.dispatchEvent("dataAnimationEnd",
                                        { chart: n })
                                }); else { if (n._breaksCanvas) if (v) n.plotArea.ctx.drawImage(n._breaksCanvas, 0, 0, this.width, this.height); else for (k = 0; k < n._axes.length; k++)n._axes[k].createMask(); 0 < n._indexLabels.length && n.renderIndexLabels(); n.dispatchEvent("dataAnimationIterationEnd", { chart: n }); n.dispatchEvent("dataAnimationEnd", { chart: n }) } this.attachPlotAreaEventHandlers(); this.zoomEnabled || (this.panEnabled || !this._zoomButton || "none" === this._zoomButton.style.display) || ta(this._zoomButton, this._resetButton); this.toolTip._updateToolTip();
                            this.renderCount++; Ga && (n = this, setTimeout(function () { var a = document.getElementById("ghostCanvasCopy"); a && (La(a, n.width, n.height), a.getContext("2d").drawImage(n._eventManager.ghostCanvas, 0, 0)) }, 2E3)); this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx); for (k = 0; k < this._axes.length; k++)this._axes[k].maskCanvas && (delete this._axes[k].maskCanvas, delete this._axes[k].maskCtx)
                        }; m.prototype.render = function (a) {
                            a && (this.options = a); this._initialize(); this.setLayout(); this.renderElements();
                            this._preRenderCanvas = null
                        }; m.prototype.attachPlotAreaEventHandlers = function () { this.attachEvent({ context: this, chart: this, mousedown: this._plotAreaMouseDown, mouseup: this._plotAreaMouseUp, mousemove: this._plotAreaMouseMove, cursor: this.panEnabled ? "move" : "default", capture: !0, bounds: this.plotArea }) }; m.prototype.categoriseDataSeries = function () {
                            for (var a = "", d = 0; d < this.data.length; d++)if (a = this.data[d], a.dataPoints && (0 !== a.dataPoints.length && a.visible) && 0 <= m._supportedChartTypes.indexOf(a.type)) {
                                for (var c =
                                    null, b = !1, e = null, f = !1, l = 0; l < this.plotInfo.plotTypes.length; l++)if (this.plotInfo.plotTypes[l].type === a.type) { b = !0; c = this.plotInfo.plotTypes[l]; break } b || (c = { type: a.type, totalDataSeries: 0, plotUnits: [] }, this.plotInfo.plotTypes.push(c)); for (l = 0; l < c.plotUnits.length; l++)if (c.plotUnits[l].axisYType === a.axisYType && c.plotUnits[l].axisXType === a.axisXType && c.plotUnits[l].axisYIndex === a.axisYIndex && c.plotUnits[l].axisXIndex === a.axisXIndex) { f = !0; e = c.plotUnits[l]; break } f || (e = {
                                        type: a.type, previousDataSeriesCount: 0,
                                        index: c.plotUnits.length, plotType: c, axisXType: a.axisXType, axisYType: a.axisYType, axisYIndex: a.axisYIndex, axisXIndex: a.axisXIndex, axisY: "primary" === a.axisYType ? this.axisY[0 <= a.axisYIndex && a.axisYIndex < this.axisY.length ? a.axisYIndex : 0] : this.axisY2[0 <= a.axisYIndex && a.axisYIndex < this.axisY2.length ? a.axisYIndex : 0], axisX: "primary" === a.axisXType ? this.axisX[0 <= a.axisXIndex && a.axisXIndex < this.axisX.length ? a.axisXIndex : 0] : this.axisX2[0 <= a.axisXIndex && a.axisXIndex < this.axisX2.length ? a.axisXIndex : 0], dataSeriesIndexes: [],
                                        yTotals: [], yAbsTotals: []
                                    }, c.plotUnits.push(e)); c.totalDataSeries++; e.dataSeriesIndexes.push(d); a.plotUnit = e
                            } for (d = 0; d < this.plotInfo.plotTypes.length; d++)for (c = this.plotInfo.plotTypes[d], l = a = 0; l < c.plotUnits.length; l++)c.plotUnits[l].previousDataSeriesCount = a, a += c.plotUnits[l].dataSeriesIndexes.length
                        }; m.prototype.assignIdToDataPoints = function () { for (var a = 0; a < this.data.length; a++) { var d = this.data[a]; if (d.dataPoints) for (var c = d.dataPoints.length, b = 0; b < c; b++)d.dataPointIds[b] = ++this._eventManager.lastObjectId } };
                m.prototype._processData = function () {
                    this.assignIdToDataPoints(); this.categoriseDataSeries(); for (var a = 0; a < this.plotInfo.plotTypes.length; a++)for (var d = this.plotInfo.plotTypes[a], c = 0; c < d.plotUnits.length; c++) {
                        var b = d.plotUnits[c]; "line" === b.type || "stepLine" === b.type || "spline" === b.type || "column" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "bar" === b.type || "bubble" === b.type || "scatter" === b.type ? this._processMultiseriesPlotUnit(b) : "stackedColumn" === b.type || "stackedBar" === b.type ||
                            "stackedArea" === b.type ? this._processStackedPlotUnit(b) : "stackedColumn100" === b.type || "stackedBar100" === b.type || "stackedArea100" === b.type ? this._processStacked100PlotUnit(b) : "candlestick" === b.type || "ohlc" === b.type || "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "error" === b.type || "boxAndWhisker" === b.type ? this._processMultiYPlotUnit(b) : "waterfall" === b.type && this._processSpecificPlotUnit(b)
                    } this.calculateAutoBreaks()
                }; m.prototype._processMultiseriesPlotUnit =
                    function (a) {
                        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var d = a.axisY.dataInfo, c = a.axisX.dataInfo, b, e, f = !1, l = 0; l < a.dataSeriesIndexes.length; l++) {
                            var u = this.data[a.dataSeriesIndexes[l]], A = 0, k = !1, n = !1, p; if ("normal" === u.axisPlacement || "xySwapped" === u.axisPlacement) var q = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ?
                                this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, g = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity; if (u.dataPoints[A].x && u.dataPoints[A].x.getTime || "dateTime" === u.xValueType) f = !0; for (A = 0; A < u.dataPoints.length; A++) {
                                    "undefined" === typeof u.dataPoints[A].x && (u.dataPoints[A].x = A + (a.axisX.logarithmic ?
                                        1 : 0)); u.dataPoints[A].x.getTime ? (f = !0, b = u.dataPoints[A].x.getTime()) : b = u.dataPoints[A].x; e = u.dataPoints[A].y; b < c.min && (c.min = b); b > c.max && (c.max = b); e < d.min && "number" === typeof e && (d.min = e); e > d.max && "number" === typeof e && (d.max = e); if (0 < A) {
                                            if (a.axisX.logarithmic) { var r = b / u.dataPoints[A - 1].x; 1 > r && (r = 1 / r); c.minDiff > r && 1 !== r && (c.minDiff = r) } else r = b - u.dataPoints[A - 1].x, 0 > r && (r *= -1), c.minDiff > r && 0 !== r && (c.minDiff = r); null !== e && null !== u.dataPoints[A - 1].y && (a.axisY.logarithmic ? (r = e / u.dataPoints[A - 1].y, 1 > r && (r =
                                                1 / r), d.minDiff > r && 1 !== r && (d.minDiff = r)) : (r = e - u.dataPoints[A - 1].y, 0 > r && (r *= -1), d.minDiff > r && 0 !== r && (d.minDiff = r)))
                                        } if (b < q && !k) null !== e && (p = b); else {
                                            if (!k && (k = !0, 0 < A)) { A -= 2; continue } if (b > g && !n) n = !0; else if (b > g && n) continue; u.dataPoints[A].label && (a.axisX.labels[b] = u.dataPoints[A].label); b < c.viewPortMin && (c.viewPortMin = b); b > c.viewPortMax && (c.viewPortMax = b); null === e ? c.viewPortMin === b && p < b && (c.viewPortMin = p) : (e < d.viewPortMin && "number" === typeof e && (d.viewPortMin = e), e > d.viewPortMax && "number" === typeof e && (d.viewPortMax =
                                                e))
                                        }
                                } u.axisX.valueType = u.xValueType = f ? "dateTime" : "number"
                        }
                    }; m.prototype._processStackedPlotUnit = function (a) {
                        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
                            for (var d = a.axisY.dataInfo, c = a.axisX.dataInfo, b, e, f = !1, l = [], u = [], A = Infinity, k = -Infinity, n = 0; n < a.dataSeriesIndexes.length; n++) {
                                var p = this.data[a.dataSeriesIndexes[n]], q = 0, g = !1, r = !1, h; if ("normal" === p.axisPlacement || "xySwapped" === p.axisPlacement) var m = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum :
                                    this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -Infinity, t = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity; if (p.dataPoints[q].x && p.dataPoints[q].x.getTime || "dateTime" === p.xValueType) f =
                                        !0; for (q = 0; q < p.dataPoints.length; q++) {
                                            "undefined" === typeof p.dataPoints[q].x && (p.dataPoints[q].x = q + (a.axisX.logarithmic ? 1 : 0)); p.dataPoints[q].x.getTime ? (f = !0, b = p.dataPoints[q].x.getTime()) : b = p.dataPoints[q].x; e = s(p.dataPoints[q].y) ? 0 : p.dataPoints[q].y; b < c.min && (c.min = b); b > c.max && (c.max = b); if (0 < q) {
                                                if (a.axisX.logarithmic) { var x = b / p.dataPoints[q - 1].x; 1 > x && (x = 1 / x); c.minDiff > x && 1 !== x && (c.minDiff = x) } else x = b - p.dataPoints[q - 1].x, 0 > x && (x *= -1), c.minDiff > x && 0 !== x && (c.minDiff = x); null !== e && null !== p.dataPoints[q -
                                                    1].y && (a.axisY.logarithmic ? 0 < e && (x = e / p.dataPoints[q - 1].y, 1 > x && (x = 1 / x), d.minDiff > x && 1 !== x && (d.minDiff = x)) : (x = e - p.dataPoints[q - 1].y, 0 > x && (x *= -1), d.minDiff > x && 0 !== x && (d.minDiff = x)))
                                            } if (b < m && !g) null !== p.dataPoints[q].y && (h = b); else {
                                                if (!g && (g = !0, 0 < q)) { q -= 2; continue } if (b > t && !r) r = !0; else if (b > t && r) continue; p.dataPoints[q].label && (a.axisX.labels[b] = p.dataPoints[q].label); b < c.viewPortMin && (c.viewPortMin = b); b > c.viewPortMax && (c.viewPortMax = b); null === p.dataPoints[q].y ? c.viewPortMin === b && h < b && (c.viewPortMin = h) :
                                                    (a.yTotals[b] = (a.yTotals[b] ? a.yTotals[b] : 0) + e, a.yAbsTotals[b] = (a.yAbsTotals[b] ? a.yAbsTotals[b] : 0) + Math.abs(e), 0 <= e ? l[b] ? l[b] += e : (l[b] = e, A = Math.min(e, A)) : u[b] ? u[b] += e : (u[b] = e, k = Math.max(e, k)))
                                            }
                                        } a.axisY.scaleBreaks && (a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks) && (d.dataPointYPositiveSums ? (d.dataPointYPositiveSums.push.apply(d.dataPointYPositiveSums, l), d.dataPointYNegativeSums.push.apply(d.dataPointYPositiveSums, u)) : (d.dataPointYPositiveSums = l, d.dataPointYNegativeSums =
                                            u)); p.axisX.valueType = p.xValueType = f ? "dateTime" : "number"
                            } for (q in l) l.hasOwnProperty(q) && !isNaN(q) && (a = l[q], a < d.min && (d.min = Math.min(a, A)), a > d.max && (d.max = a), q < c.viewPortMin || q > c.viewPortMax || (a < d.viewPortMin && (d.viewPortMin = Math.min(a, A)), a > d.viewPortMax && (d.viewPortMax = a))); for (q in u) u.hasOwnProperty(q) && !isNaN(q) && (a = u[q], a < d.min && (d.min = a), a > d.max && (d.max = Math.max(a, k)), q < c.viewPortMin || q > c.viewPortMax || (a < d.viewPortMin && (d.viewPortMin = a), a > d.viewPortMax && (d.viewPortMax = Math.max(a, k))))
                        }
                    }; m.prototype._processStacked100PlotUnit =
                        function (a) {
                            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
                                for (var d = a.axisY.dataInfo, c = a.axisX.dataInfo, b, e, f = !1, l = !1, u = !1, A = [], k = 0; k < a.dataSeriesIndexes.length; k++) {
                                    var n = this.data[a.dataSeriesIndexes[k]], p = 0, q = !1, g = !1, r; if ("normal" === n.axisPlacement || "xySwapped" === n.axisPlacement) var h = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ?
                                        this.options.axisX.minimum : -Infinity, m = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity; if (n.dataPoints[p].x && n.dataPoints[p].x.getTime || "dateTime" === n.xValueType) f = !0; for (p = 0; p < n.dataPoints.length; p++) {
                                            "undefined" === typeof n.dataPoints[p].x && (n.dataPoints[p].x = p + (a.axisX.logarithmic ? 1 : 0));
                                            n.dataPoints[p].x.getTime ? (f = !0, b = n.dataPoints[p].x.getTime()) : b = n.dataPoints[p].x; e = s(n.dataPoints[p].y) ? null : n.dataPoints[p].y; b < c.min && (c.min = b); b > c.max && (c.max = b); if (0 < p) {
                                                if (a.axisX.logarithmic) { var t = b / n.dataPoints[p - 1].x; 1 > t && (t = 1 / t); c.minDiff > t && 1 !== t && (c.minDiff = t) } else t = b - n.dataPoints[p - 1].x, 0 > t && (t *= -1), c.minDiff > t && 0 !== t && (c.minDiff = t); s(e) || null === n.dataPoints[p - 1].y || (a.axisY.logarithmic ? 0 < e && (t = e / n.dataPoints[p - 1].y, 1 > t && (t = 1 / t), d.minDiff > t && 1 !== t && (d.minDiff = t)) : (t = e - n.dataPoints[p -
                                                    1].y, 0 > t && (t *= -1), d.minDiff > t && 0 !== t && (d.minDiff = t)))
                                            } if (b < h && !q) null !== e && (r = b); else {
                                                if (!q && (q = !0, 0 < p)) { p -= 2; continue } if (b > m && !g) g = !0; else if (b > m && g) continue; n.dataPoints[p].label && (a.axisX.labels[b] = n.dataPoints[p].label); b < c.viewPortMin && (c.viewPortMin = b); b > c.viewPortMax && (c.viewPortMax = b); null === e ? c.viewPortMin === b && r < b && (c.viewPortMin = r) : (a.yTotals[b] = (a.yTotals[b] ? a.yTotals[b] : 0) + e, a.yAbsTotals[b] = (a.yAbsTotals[b] ? a.yAbsTotals[b] : 0) + Math.abs(e), 0 <= e ? l = !0 : 0 > e && (u = !0), A[b] = A[b] ? A[b] + Math.abs(e) :
                                                    Math.abs(e))
                                            }
                                        } n.axisX.valueType = n.xValueType = f ? "dateTime" : "number"
                                } a.axisY.logarithmic ? (d.max = s(d.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -0.05) : Math.max(d.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -0.05)), d.min = s(d.viewPortMin) ? 1 : Math.min(d.viewPortMin, 1)) : l && !u ? (d.max = s(d.viewPortMax) ? 99 : Math.max(d.viewPortMax, 99), d.min = s(d.viewPortMin) ? 1 : Math.min(d.viewPortMin, 1)) : l && u ? (d.max = s(d.viewPortMax) ? 99 : Math.max(d.viewPortMax, 99), d.min = s(d.viewPortMin) ? -99 : Math.min(d.viewPortMin, -99)) : !l && u &&
                                    (d.max = s(d.viewPortMax) ? -1 : Math.max(d.viewPortMax, -1), d.min = s(d.viewPortMin) ? -99 : Math.min(d.viewPortMin, -99)); d.viewPortMin = d.min; d.viewPortMax = d.max; a.dataPointYSums = A
                            }
                        }; m.prototype._processMultiYPlotUnit = function (a) {
                            if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) for (var d = a.axisY.dataInfo, c = a.axisX.dataInfo, b, e, f, l, u = !1, A = 0; A < a.dataSeriesIndexes.length; A++) {
                                var k = this.data[a.dataSeriesIndexes[A]], n = 0, p = !1, q = !1, g, r, h; if ("normal" === k.axisPlacement || "xySwapped" === k.axisPlacement) var m = a.axisX.sessionVariables.newViewportMinimum ?
                                    a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : a.axisX.logarithmic ? 0 : -Infinity, t = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity;
                                if (k.dataPoints[n].x && k.dataPoints[n].x.getTime || "dateTime" === k.xValueType) u = !0; for (n = 0; n < k.dataPoints.length; n++) {
                                    "undefined" === typeof k.dataPoints[n].x && (k.dataPoints[n].x = n + (a.axisX.logarithmic ? 1 : 0)); k.dataPoints[n].x.getTime ? (u = !0, b = k.dataPoints[n].x.getTime()) : b = k.dataPoints[n].x; if ((e = k.dataPoints[n].y) && e.length) { f = Math.min.apply(null, e); l = Math.max.apply(null, e); r = !0; for (var x = 0; x < e.length; x++)null === e.k && (r = !1); r && (p || (h = g), g = b) } b < c.min && (c.min = b); b > c.max && (c.max = b); f < d.min && (d.min = f); l > d.max &&
                                        (d.max = l); 0 < n && (a.axisX.logarithmic ? (r = b / k.dataPoints[n - 1].x, 1 > r && (r = 1 / r), c.minDiff > r && 1 !== r && (c.minDiff = r)) : (r = b - k.dataPoints[n - 1].x, 0 > r && (r *= -1), c.minDiff > r && 0 !== r && (c.minDiff = r)), e && (null !== e[0] && k.dataPoints[n - 1].y && null !== k.dataPoints[n - 1].y[0]) && (a.axisY.logarithmic ? (r = e[0] / k.dataPoints[n - 1].y[0], 1 > r && (r = 1 / r), d.minDiff > r && 1 !== r && (d.minDiff = r)) : (r = e[0] - k.dataPoints[n - 1].y[0], 0 > r && (r *= -1), d.minDiff > r && 0 !== r && (d.minDiff = r)))); if (!(b < m) || p) {
                                            if (!p && (p = !0, 0 < n)) { n -= 2; g = h; continue } if (b > t && !q) q = !0; else if (b >
                                                t && q) continue; k.dataPoints[n].label && (a.axisX.labels[b] = k.dataPoints[n].label); b < c.viewPortMin && (c.viewPortMin = b); b > c.viewPortMax && (c.viewPortMax = b); if (c.viewPortMin === b && e) for (x = 0; x < e.length; x++)if (null === e[x] && g < b) { c.viewPortMin = g; break } null === e ? c.viewPortMin === b && g < b && (c.viewPortMin = g) : (f < d.viewPortMin && (d.viewPortMin = f), l > d.viewPortMax && (d.viewPortMax = l))
                                        }
                                } k.axisX.valueType = k.xValueType = u ? "dateTime" : "number"
                            }
                        }; m.prototype._processSpecificPlotUnit = function (a) {
                            if ("waterfall" === a.type && a.dataSeriesIndexes &&
                                !(1 > a.dataSeriesIndexes.length)) for (var d = a.axisY.dataInfo, c = a.axisX.dataInfo, b, e, f = !1, l = 0; l < a.dataSeriesIndexes.length; l++) {
                                    var u = this.data[a.dataSeriesIndexes[l]], A = 0, k = !1, n = !1, p = b = 0; if ("normal" === u.axisPlacement || "xySwapped" === u.axisPlacement) var q = a.axisX.sessionVariables.newViewportMinimum ? a.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum :
                                        a.axisX.logarithmic ? 0 : -Infinity, g = a.axisX.sessionVariables.newViewportMaximum ? a.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : Infinity; if (u.dataPoints[A].x && u.dataPoints[A].x.getTime || "dateTime" === u.xValueType) f = !0; for (A = 0; A < u.dataPoints.length; A++)"undefined" !== typeof u.dataPoints[A].isCumulativeSum && !0 === u.dataPoints[A].isCumulativeSum ? (u.dataPointEOs[A].cumulativeSumYStartValue =
                                            0, u.dataPointEOs[A].cumulativeSum = 0 === A ? 0 : u.dataPointEOs[A - 1].cumulativeSum, u.dataPoints[A].y = 0 === A ? 0 : u.dataPointEOs[A - 1].cumulativeSum) : "undefined" !== typeof u.dataPoints[A].isIntermediateSum && !0 === u.dataPoints[A].isIntermediateSum ? (u.dataPointEOs[A].cumulativeSumYStartValue = p, u.dataPointEOs[A].cumulativeSum = 0 === A ? 0 : u.dataPointEOs[A - 1].cumulativeSum, u.dataPoints[A].y = 0 === A ? 0 : b, p = 0 === A ? 0 : u.dataPointEOs[A - 1].cumulativeSum, b = 0) : (e = "number" !== typeof u.dataPoints[A].y ? 0 : u.dataPoints[A].y, u.dataPointEOs[A].cumulativeSumYStartValue =
                                                0 === A ? 0 : u.dataPointEOs[A - 1].cumulativeSum, u.dataPointEOs[A].cumulativeSum = 0 === A ? e : u.dataPointEOs[A - 1].cumulativeSum + e, b += e); for (A = 0; A < u.dataPoints.length; A++)if ("undefined" === typeof u.dataPoints[A].x && (u.dataPoints[A].x = A + (a.axisX.logarithmic ? 1 : 0)), u.dataPoints[A].x.getTime ? (f = !0, b = u.dataPoints[A].x.getTime()) : b = u.dataPoints[A].x, e = u.dataPoints[A].y, b < c.min && (c.min = b), b > c.max && (c.max = b), u.dataPointEOs[A].cumulativeSum < d.min && (d.min = u.dataPointEOs[A].cumulativeSum), u.dataPointEOs[A].cumulativeSum >
                                                    d.max && (d.max = u.dataPointEOs[A].cumulativeSum), 0 < A && (a.axisX.logarithmic ? (p = b / u.dataPoints[A - 1].x, 1 > p && (p = 1 / p), c.minDiff > p && 1 !== p && (c.minDiff = p)) : (p = b - u.dataPoints[A - 1].x, 0 > p && (p *= -1), c.minDiff > p && 0 !== p && (c.minDiff = p)), null !== e && null !== u.dataPoints[A - 1].y && (a.axisY.logarithmic ? (e = u.dataPointEOs[A].cumulativeSum / u.dataPointEOs[A - 1].cumulativeSum, 1 > e && (e = 1 / e), d.minDiff > e && 1 !== e && (d.minDiff = e)) : (e = u.dataPointEOs[A].cumulativeSum - u.dataPointEOs[A - 1].cumulativeSum, 0 > e && (e *= -1), d.minDiff > e && 0 !== e && (d.minDiff =
                                                        e)))), !(b < q) || k) {
                                                            if (!k && (k = !0, 0 < A)) { A -= 2; continue } if (b > g && !n) n = !0; else if (b > g && n) continue; u.dataPoints[A].label && (a.axisX.labels[b] = u.dataPoints[A].label); b < c.viewPortMin && (c.viewPortMin = b); b > c.viewPortMax && (c.viewPortMax = b); 0 < A && (u.dataPointEOs[A - 1].cumulativeSum < d.viewPortMin && (d.viewPortMin = u.dataPointEOs[A - 1].cumulativeSum), u.dataPointEOs[A - 1].cumulativeSum > d.viewPortMax && (d.viewPortMax = u.dataPointEOs[A - 1].cumulativeSum)); u.dataPointEOs[A].cumulativeSum < d.viewPortMin && (d.viewPortMin = u.dataPointEOs[A].cumulativeSum);
                                                    u.dataPointEOs[A].cumulativeSum > d.viewPortMax && (d.viewPortMax = u.dataPointEOs[A].cumulativeSum)
                                                } u.axisX.valueType = u.xValueType = f ? "dateTime" : "number"
                                }
                        }; m.prototype.calculateAutoBreaks = function () {
                            function a(a, b, c, e) { if (e) return c = Math.pow(Math.min(c * a / b, b / a), 0.2), 1 >= c && (c = Math.pow(1 > a ? 1 / a : Math.min(b / a, a), 0.25)), { startValue: a * c, endValue: b / c }; c = 0.2 * Math.min(c - b + a, b - a); 0 >= c && (c = 0.25 * Math.min(b - a, Math.abs(a))); return { startValue: a + c, endValue: b - c } } function d(a) {
                                if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
                                    var b =
                                        a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks, c = a.axisY.scaleBreaks && a.axisY.scaleBreaks.autoCalculate && 1 <= a.axisY.scaleBreaks.maxNumberOfAutoBreaks; if (b || c) for (var d = a.axisY.dataInfo, f = a.axisX.dataInfo, g, k = f.min, l = f.max, n = d.min, p = d.max, f = f._dataRanges, d = d._dataRanges, q, u = 0, A = 0; A < a.dataSeriesIndexes.length; A++) {
                                            var h = e.data[a.dataSeriesIndexes[A]]; if (!(4 > h.dataPoints.length)) for (u = 0; u < h.dataPoints.length; u++)if (b && (q = (l + 1 - k) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) ||
                                                10, 10) / 100, g = h.dataPoints[u].x.getTime ? h.dataPoints[u].x.getTime() : h.dataPoints[u].x, q = Math.floor((g - k) / q), g < f[q].min && (f[q].min = g), g > f[q].max && (f[q].max = g)), c) {
                                                    var m = (p + 1 - n) * Math.max(parseFloat(a.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100; if ((g = "waterfall" === a.type ? h.dataPointEOs[u].cumulativeSum : h.dataPoints[u].y) && g.length) for (var v = 0; v < g.length; v++)q = Math.floor((g[v] - n) / m), g[v] < d[q].min && (d[q].min = g[v]), g[v] > d[q].max && (d[q].max = g[v]); else s(g) || (q = Math.floor((g - n) / m), g < d[q].min && (d[q].min =
                                                        g), g > d[q].max && (d[q].max = g))
                                            }
                                        }
                                }
                            } function c(a) {
                                if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length) && a.axisX.scaleBreaks && a.axisX.scaleBreaks.autoCalculate && 1 <= a.axisX.scaleBreaks.maxNumberOfAutoBreaks) for (var b = a.axisX.dataInfo, c = b.min, d = b.max, f = b._dataRanges, g, k = 0, l = 0; l < a.dataSeriesIndexes.length; l++) {
                                    var n = e.data[a.dataSeriesIndexes[l]]; if (!(4 > n.dataPoints.length)) for (k = 0; k < n.dataPoints.length; k++)g = (d + 1 - c) * Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, b = n.dataPoints[k].x.getTime ?
                                        n.dataPoints[k].x.getTime() : n.dataPoints[k].x, g = Math.floor((b - c) / g), b < f[g].min && (f[g].min = b), b > f[g].max && (f[g].max = b)
                                }
                            } for (var b, e = this, f = !1, l = 0; l < this._axes.length; l++)if (this._axes[l].scaleBreaks && this._axes[l].scaleBreaks.autoCalculate && 1 <= this._axes[l].scaleBreaks.maxNumberOfAutoBreaks) { f = !0; this._axes[l].dataInfo._dataRanges = []; for (var u = 0; u < 100 / Math.max(parseFloat(this._axes[l].scaleBreaks.collapsibleThreshold) || 10, 10); u++)this._axes[l].dataInfo._dataRanges.push({ min: Infinity, max: -Infinity }) } if (f) {
                                for (l =
                                    0; l < this.plotInfo.plotTypes.length; l++)for (f = this.plotInfo.plotTypes[l], u = 0; u < f.plotUnits.length; u++)b = f.plotUnits[u], "line" === b.type || "stepLine" === b.type || "spline" === b.type || "column" === b.type || "area" === b.type || "stepArea" === b.type || "splineArea" === b.type || "bar" === b.type || "bubble" === b.type || "scatter" === b.type || "candlestick" === b.type || "ohlc" === b.type || "rangeColumn" === b.type || "rangeBar" === b.type || "rangeArea" === b.type || "rangeSplineArea" === b.type || "waterfall" === b.type || "error" === b.type || "boxAndWhisker" ===
                                        b.type ? d(b) : 0 <= b.type.indexOf("stacked") && c(b); for (l = 0; l < this._axes.length; l++)if (this._axes[l].dataInfo._dataRanges) {
                                            var A = this._axes[l].dataInfo.min; b = (this._axes[l].dataInfo.max + 1 - A) * Math.max(parseFloat(this._axes[l].scaleBreaks.collapsibleThreshold) || 10, 10) / 100; var k = this._axes[l].dataInfo._dataRanges, n, p, f = []; if (this._axes[l].dataInfo.dataPointYPositiveSums) {
                                                var q = this._axes[l].dataInfo.dataPointYPositiveSums; n = k; for (u in q) if (q.hasOwnProperty(u) && !isNaN(u) && (p = q[u], !s(p))) {
                                                    var g = Math.floor((p -
                                                        A) / b); p < n[g].min && (n[g].min = p); p > n[g].max && (n[g].max = p)
                                                } delete this._axes[l].dataInfo.dataPointYPositiveSums
                                            } if (this._axes[l].dataInfo.dataPointYNegativeSums) { q = this._axes[l].dataInfo.dataPointYNegativeSums; n = k; for (u in q) q.hasOwnProperty(u) && !isNaN(u) && (p = -1 * q[u], s(p) || (g = Math.floor((p - A) / b), p < n[g].min && (n[g].min = p), p > n[g].max && (n[g].max = p))); delete this._axes[l].dataInfo.dataPointYNegativeSums } for (u = 0; u < k.length - 1; u++)if (n = k[u].max, isFinite(n)) for (; u < k.length - 1;)if (A = k[u + 1].min, isFinite(A)) {
                                                p = A -
                                                n; p > b && f.push({ diff: p, start: n, end: A }); break
                                            } else u++; if (this._axes[l].scaleBreaks.customBreaks) for (u = 0; u < this._axes[l].scaleBreaks.customBreaks.length; u++)for (b = 0; b < f.length; b++)if (this._axes[l].scaleBreaks.customBreaks[u].startValue <= f[b].start && f[b].start <= this._axes[l].scaleBreaks.customBreaks[u].endValue || this._axes[l].scaleBreaks.customBreaks[u].startValue <= f[b].start && f[b].start <= this._axes[l].scaleBreaks.customBreaks[u].endValue || f[b].start <= this._axes[l].scaleBreaks.customBreaks[u].startValue &&
                                                this._axes[l].scaleBreaks.customBreaks[u].startValue <= f[b].end || f[b].start <= this._axes[l].scaleBreaks.customBreaks[u].endValue && this._axes[l].scaleBreaks.customBreaks[u].endValue <= f[b].end) f.splice(b, 1), b--; f.sort(function (a, b) { return b.diff - a.diff }); for (u = 0; u < Math.min(f.length, this._axes[l].scaleBreaks.maxNumberOfAutoBreaks); u++)b = a(f[u].start, f[u].end, this._axes[l].logarithmic ? this._axes[l].dataInfo.max / this._axes[l].dataInfo.min : this._axes[l].dataInfo.max - this._axes[l].dataInfo.min, this._axes[l].logarithmic),
                                                    this._axes[l].scaleBreaks.autoBreaks.push(new U(this, "autoBreaks", b, u, ++this._eventManager.lastObjectId, this._axes[l].scaleBreaks)), this._axes[l].scaleBreaks._appliedBreaks.push(this._axes[l].scaleBreaks.autoBreaks[this._axes[l].scaleBreaks.autoBreaks.length - 1]); this._axes[l].scaleBreaks._appliedBreaks.sort(function (a, b) { return a.startValue - b.startValue })
                                        }
                            }
                        }; m.prototype.renderCrosshairs = function (a) {
                            for (var d = 0; d < this.axisX.length; d++)this.axisX[d] != a && (this.axisX[d].crosshair && this.axisX[d].crosshair.enabled &&
                                !this.axisX[d].crosshair._hidden) && this.axisX[d].showCrosshair(this.axisX[d].crosshair._updatedValue); for (d = 0; d < this.axisX2.length; d++)this.axisX2[d] != a && (this.axisX2[d].crosshair && this.axisX2[d].crosshair.enabled && !this.axisX2[d].crosshair._hidden) && this.axisX2[d].showCrosshair(this.axisX2[d].crosshair._updatedValue); for (d = 0; d < this.axisY.length; d++)this.axisY[d] != a && (this.axisY[d].crosshair && this.axisY[d].crosshair.enabled && !this.axisY[d].crosshair._hidden) && this.axisY[d].showCrosshair(this.axisY[d].crosshair._updatedValue);
                            for (d = 0; d < this.axisY2.length; d++)this.axisY2[d] != a && (this.axisY2[d].crosshair && this.axisY2[d].crosshair.enabled && !this.axisY2[d].crosshair._hidden) && this.axisY2[d].showCrosshair(this.axisY2[d].crosshair._updatedValue)
                        }; m.prototype.getDataPointAtXY = function (a, d, c) {
                            c = c || !1; for (var b = [], e = this._dataInRenderedOrder.length - 1; 0 <= e; e--) { var f = null; (f = this._dataInRenderedOrder[e].getDataPointAtXY(a, d, c)) && b.push(f) } a = null; d = !1; for (c = 0; c < b.length; c++)if ("line" === b[c].dataSeries.type || "stepLine" === b[c].dataSeries.type ||
                                "area" === b[c].dataSeries.type || "stepArea" === b[c].dataSeries.type) if (e = ka("markerSize", b[c].dataPoint, b[c].dataSeries) || 8, b[c].distance <= e / 2) { d = !0; break } for (c = 0; c < b.length; c++)d && "line" !== b[c].dataSeries.type && "stepLine" !== b[c].dataSeries.type && "area" !== b[c].dataSeries.type && "stepArea" !== b[c].dataSeries.type || (a ? b[c].distance <= a.distance && (a = b[c]) : a = b[c]); return a
                        }; m.prototype.getObjectAtXY = function (a, d, c) {
                            var b = null; if (c = this.getDataPointAtXY(a, d, c || !1)) b = c.dataSeries.dataPointIds[c.dataPointIndex];
                            else if (v) b = Ya(a, d, this._eventManager.ghostCtx); else for (c = 0; c < this.legend.items.length; c++) { var e = this.legend.items[c]; a >= e.x1 && (a <= e.x2 && d >= e.y1 && d <= e.y2) && (b = e.id) } return b
                        }; m.prototype.getAutoFontSize = lb; m.prototype.resetOverlayedCanvas = function () { this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height) }; m.prototype.clearCanvas = kb; m.prototype.attachEvent = function (a) { this._events.push(a) }; m.prototype._touchEventHandler = function (a) {
                            if (a.changedTouches && this.interactivityEnabled) {
                                var d = [], c =
                                    a.changedTouches, b = c ? c[0] : a, e = null; switch (a.type) { case "touchstart": case "MSPointerDown": d = ["mousemove", "mousedown"]; this._lastTouchData = Na(b); this._lastTouchData.time = new Date; break; case "touchmove": case "MSPointerMove": d = ["mousemove"]; break; case "touchend": case "MSPointerUp": var f = this._lastTouchData && this._lastTouchData.time ? new Date - this._lastTouchData.time : 0, d = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType || 300 > f ? ["mouseup", "click"] : ["mouseup"]; break; default: return }if (!(c &&
                                        1 < c.length)) {
                                            e = Na(b); e.time = new Date; try { var l = e.y - this._lastTouchData.y, f = e.time - this._lastTouchData.time; if (1 < Math.abs(l) && this._lastTouchData.scroll || 5 < Math.abs(l) && 250 > f) this._lastTouchData.scroll = !0 } catch (u) { } this._lastTouchEventType = a.type; if (this._lastTouchData.scroll && this.zoomEnabled) this.isDrag && this.resetOverlayedCanvas(), this.isDrag = !1; else for (c = 0; c < d.length; c++)if (e = d[c], l = document.createEvent("MouseEvent"), l.initMouseEvent(e, !0, !0, window, 1, b.screenX, b.screenY, b.clientX, b.clientY, !1,
                                                !1, !1, !1, 0, null), b.target.dispatchEvent(l), !s(this._lastTouchData.scroll) && !this._lastTouchData.scroll || !this._lastTouchData.scroll && 250 < f || "click" === e) a.preventManipulation && a.preventManipulation(), a.preventDefault && a.cancelable && a.preventDefault()
                                }
                            }
                        }; m.prototype._dispatchRangeEvent = function (a, d) {
                            var c = { chart: this }; c.type = a; c.trigger = d; var b = []; this.axisX && 0 < this.axisX.length && b.push("axisX"); this.axisX2 && 0 < this.axisX2.length && b.push("axisX2"); this.axisY && 0 < this.axisY.length && b.push("axisY"); this.axisY2 &&
                                0 < this.axisY2.length && b.push("axisY2"); for (var e = 0; e < b.length; e++)if (s(c[b[e]]) && (c[b[e]] = []), "axisY" === b[e]) for (var f = 0; f < this.axisY.length; f++)c[b[e]].push({ viewportMinimum: this[b[e]][f].sessionVariables.newViewportMinimum, viewportMaximum: this[b[e]][f].sessionVariables.newViewportMaximum }); else if ("axisY2" === b[e]) for (f = 0; f < this.axisY2.length; f++)c[b[e]].push({ viewportMinimum: this[b[e]][f].sessionVariables.newViewportMinimum, viewportMaximum: this[b[e]][f].sessionVariables.newViewportMaximum }); else if ("axisX" ===
                                    b[e]) for (f = 0; f < this.axisX.length; f++)c[b[e]].push({ viewportMinimum: this[b[e]][f].sessionVariables.newViewportMinimum, viewportMaximum: this[b[e]][f].sessionVariables.newViewportMaximum }); else if ("axisX2" === b[e]) for (f = 0; f < this.axisX2.length; f++)c[b[e]].push({ viewportMinimum: this[b[e]][f].sessionVariables.newViewportMinimum, viewportMaximum: this[b[e]][f].sessionVariables.newViewportMaximum }); this.dispatchEvent(a, c, this)
                        }; m.prototype._mouseEventHandler = function (a) {
                            "undefined" === typeof a.target && a.srcElement &&
                            (a.target = a.srcElement); var d = Na(a), c = a.type, b, e; a.which ? e = 3 == a.which : a.button && (e = 2 == a.button); m.capturedEventParam && (b = m.capturedEventParam, "mouseup" === c && (m.capturedEventParam = null, b.chart.overlaidCanvas.releaseCapture ? b.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", b.chart._mouseEventHandler, !1)), b.hasOwnProperty(c) && ("mouseup" !== c || b.chart.overlaidCanvas.releaseCapture ? a.target !== b.chart.overlaidCanvas && v || b[c].call(b.context, d.x, d.y) : a.target !==
                                b.chart.overlaidCanvas && (b.chart.isDrag = !1))); if (this.interactivityEnabled) if (this._ignoreNextEvent) this._ignoreNextEvent = !1; else if (a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault(), Ga && window.//console && (window.//////console.log(c + " --\x3e x: " + d.x + "; y:" + d.y), e && window.//////console.log(a.which), "mouseup" === c && window.//////console.log("mouseup")), !e) {
                                    if (!m.capturedEventParam && this._events) {
                                        for (var f = 0; f < this._events.length; f++)if (this._events[f].hasOwnProperty(c)) if (b = this._events[f],
                                            e = b.bounds, d.x >= e.x1 && d.x <= e.x2 && d.y >= e.y1 && d.y <= e.y2) { b[c].call(b.context, d.x, d.y); "mousedown" === c && !0 === b.capture ? (m.capturedEventParam = b, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener("mouseup", this._mouseEventHandler, !1)) : "mouseup" === c && (b.chart.overlaidCanvas.releaseCapture ? b.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, !1)); break } else b = null; a.target.style.cursor =
                                                b && b.cursor ? b.cursor : this._defaultCursor
                                    } c = this.plotArea; if (d.x < c.x1 || d.x > c.x2 || d.y < c.y1 || d.y > c.y2) if (this.toolTip && this.toolTip.enabled) {
                                        this.toolTip.hide(); this.toolTip.dispatchEvent("hidden", { chart: this, toolTip: this.toolTip }, this.toolTip); for (f = 0; f < this.axisX.length; f++)this.axisX[f].crosshair && this.axisX[f].crosshair.enabled && this.axisX[f].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX[f].options }, this.axisX[f].crosshair); for (f = 0; f < this.axisX2.length; f++)this.axisX2[f].crosshair &&
                                            this.axisX2[f].crosshair.enabled && this.axisX2[f].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisX2[f].options }, this.axisX2[f].crosshair); for (f = 0; f < this.axisY.length; f++)this.axisY[f].crosshair && this.axisY[f].crosshair.enabled && this.axisY[f].crosshair.dispatchEvent("hidden", { chart: this, axis: this.axisY[f].options }, this.axisY[f].crosshair); for (f = 0; f < this.axisY2.length; f++)this.axisY2[f].crosshair && this.axisY2[f].crosshair.enabled && this.axisY2[f].crosshair.dispatchEvent("hidden", {
                                                chart: this,
                                                axis: this.axisY2[f].options
                                            }, this.axisY2[f].crosshair)
                                    } else this.resetOverlayedCanvas(); this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a)
                                }
                        }; m.prototype._plotAreaMouseDown = function (a, d) { this.isDrag = !0; this.dragStartPoint = { x: a, y: d } }; m.prototype._plotAreaMouseUp = function (a, d) {
                            if (("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) && this.isDrag) {
                                var c = d - this.dragStartPoint.y, b = a - this.dragStartPoint.x, e = 0 <= this.zoomType.indexOf("x"),
                                f = 0 <= this.zoomType.indexOf("y"), l = !1; this.resetOverlayedCanvas(); if ("xySwapped" === this.plotInfo.axisPlacement) var u = f, f = e, e = u; if (this.panEnabled || this.zoomEnabled) {
                                    if (this.panEnabled) for (e = f = 0; e < this._axes.length; e++)c = this._axes[e], c.logarithmic ? c.viewportMinimum < c.minimum ? (f = c.minimum / c.viewportMinimum, c.sessionVariables.newViewportMinimum = c.viewportMinimum * f, c.sessionVariables.newViewportMaximum = c.viewportMaximum * f, l = !0) : c.viewportMaximum > c.maximum && (f = c.viewportMaximum / c.maximum, c.sessionVariables.newViewportMinimum =
                                        c.viewportMinimum / f, c.sessionVariables.newViewportMaximum = c.viewportMaximum / f, l = !0) : c.viewportMinimum < c.minimum ? (f = c.minimum - c.viewportMinimum, c.sessionVariables.newViewportMinimum = c.viewportMinimum + f, c.sessionVariables.newViewportMaximum = c.viewportMaximum + f, l = !0) : c.viewportMaximum > c.maximum && (f = c.viewportMaximum - c.maximum, c.sessionVariables.newViewportMinimum = c.viewportMinimum - f, c.sessionVariables.newViewportMaximum = c.viewportMaximum - f, l = !0); else if ((!e || 2 < Math.abs(b)) && (!f || 2 < Math.abs(c)) && this.zoomEnabled) {
                                            if (!this.dragStartPoint) return;
                                            c = e ? this.dragStartPoint.x : this.plotArea.x1; b = f ? this.dragStartPoint.y : this.plotArea.y1; e = e ? a : this.plotArea.x2; f = f ? d : this.plotArea.y2; 2 < Math.abs(c - e) && 2 < Math.abs(b - f) && this._zoomPanToSelectedRegion(c, b, e, f) && (l = !0)
                                        } l && (this._ignoreNextEvent = !0, this._dispatchRangeEvent("rangeChanging", "zoom"), this.stockChart && (this.stockChart.navigator && this.stockChart.navigator.enabled) && (this.stockChart._rangeEventParameter || (this.stockChart._rangeEventParameter = {
                                            stockChart: this.stockChart, source: "chart", index: this.stockChart.charts.indexOf(this),
                                            minimum: this.stockChart.sessionVariables._axisXMin, maximum: this.stockChart.sessionVariables._axisXMax
                                        }), this.stockChart._rangeEventParameter.type = "rangeChanging", this.stockChart.dispatchEvent("rangeChanging", this.stockChart._rangeEventParameter, this.stockChart)), this.render(), this._dispatchRangeEvent("rangeChanged", "zoom"), this.stockChart && (this.stockChart.navigator && this.stockChart.navigator.enabled) && (this.stockChart._rangeEventParameter.type = "rangeChanged", this.stockChart.dispatchEvent("rangeChanged",
                                            this.stockChart._rangeEventParameter, this.stockChart)), l && (this.zoomEnabled && "none" === this._zoomButton.style.display) && (Ka(this._zoomButton, this._resetButton), ua(this, this._zoomButton, "pan"), ua(this, this._resetButton, "reset")))
                                }
                            } this.isDrag = !1; if ("none" !== this.plotInfo.axisPlacement) {
                                this.resetOverlayedCanvas(); if (this.axisX && 0 < this.axisX.length) for (l = 0; l < this.axisX.length; l++)this.axisX[l].crosshair && this.axisX[l].crosshair.enabled && this.axisX[l].renderCrosshair(a, d); if (this.axisX2 && 0 < this.axisX2.length) for (l =
                                    0; l < this.axisX2.length; l++)this.axisX2[l].crosshair && this.axisX2[l].crosshair.enabled && this.axisX2[l].renderCrosshair(a, d); if (this.axisY && 0 < this.axisY.length) for (l = 0; l < this.axisY.length; l++)this.axisY[l].crosshair && this.axisY[l].crosshair.enabled && this.axisY[l].renderCrosshair(a, d); if (this.axisY2 && 0 < this.axisY2.length) for (l = 0; l < this.axisY2.length; l++)this.axisY2[l].crosshair && this.axisY2[l].crosshair.enabled && this.axisY2[l].renderCrosshair(a, d)
                            }
                        }; m.prototype._plotAreaMouseMove = function (a, d) {
                            if (this.isDrag &&
                                "none" !== this.plotInfo.axisPlacement) {
                                    var c = 0, b = 0, e = c = null, e = 0 <= this.zoomType.indexOf("x"), f = 0 <= this.zoomType.indexOf("y"), l = this; "xySwapped" === this.plotInfo.axisPlacement && (c = f, f = e, e = c); c = this.dragStartPoint.x - a; b = this.dragStartPoint.y - d; 2 < Math.abs(c) && 8 > Math.abs(c) && (this.panEnabled || this.zoomEnabled) ? (this.toolTip.hide(), this.toolTip.dispatchEvent("hidden", { chart: this, toolTip: this.toolTip }, this.toolTip)) : this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(a, d); if ((!e || 2 < Math.abs(c) ||
                                        !f || 2 < Math.abs(b)) && (this.panEnabled || this.zoomEnabled)) if (this.panEnabled) e = { x1: e ? this.plotArea.x1 + c : this.plotArea.x1, y1: f ? this.plotArea.y1 + b : this.plotArea.y1, x2: e ? this.plotArea.x2 + c : this.plotArea.x2, y2: f ? this.plotArea.y2 + b : this.plotArea.y2 }, clearTimeout(l._panTimerId), l._panTimerId = setTimeout(function (b, c, e, f) {
                                            return function () {
                                                l._zoomPanToSelectedRegion(b, c, e, f, !0) && (l._dispatchRangeEvent("rangeChanging", "pan"), l.stockChart && (l.stockChart.navigator && l.stockChart.navigator.enabled) && (l.stockChart._rangeEventParameter.type =
                                                    "rangeChanging", l.stockChart.dispatchEvent("rangeChanging", l.stockChart._rangeEventParameter, l.stockChart)), l.render(), l._dispatchRangeEvent("rangeChanged", "pan"), l.stockChart && (l.stockChart.navigator && l.stockChart.navigator.enabled) && (l.stockChart._rangeEventParameter.type = "rangeChanged", l.stockChart.dispatchEvent("rangeChanged", l.stockChart._rangeEventParameter, l.stockChart)), l.dragStartPoint.x = a, l.dragStartPoint.y = d)
                                            }
                                        }(e.x1, e.y1, e.x2, e.y2), 0); else if (this.zoomEnabled) {
                                            this.resetOverlayedCanvas();
                                            c = this.overlaidCanvasCtx.globalAlpha; this.overlaidCanvasCtx.fillStyle = "#A89896"; var b = e ? this.dragStartPoint.x : this.plotArea.x1, u = f ? this.dragStartPoint.y : this.plotArea.y1, A = e ? a - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1, k = f ? d - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1; this.validateRegion(b, u, e ? a : this.plotArea.x2 - this.plotArea.x1, f ? d : this.plotArea.y2 - this.plotArea.y1, "xy" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = "#99B2B5"); this.overlaidCanvasCtx.globalAlpha =
                                                0.7; this.overlaidCanvasCtx.fillRect(b, u, A, k); this.overlaidCanvasCtx.globalAlpha = c
                                        }
                            } else if (this.toolTip.mouseMoveHandler(a, d), "none" !== this.plotInfo.axisPlacement) {
                                if (this.axisX && 0 < this.axisX.length) for (e = 0; e < this.axisX.length; e++)this.axisX[e].crosshair && this.axisX[e].crosshair.enabled && this.axisX[e].renderCrosshair(a, d); if (this.axisX2 && 0 < this.axisX2.length) for (e = 0; e < this.axisX2.length; e++)this.axisX2[e].crosshair && this.axisX2[e].crosshair.enabled && this.axisX2[e].renderCrosshair(a, d); if (this.axisY &&
                                    0 < this.axisY.length) for (e = 0; e < this.axisY.length; e++)this.axisY[e].crosshair && this.axisY[e].crosshair.enabled && this.axisY[e].renderCrosshair(a, d); if (this.axisY2 && 0 < this.axisY2.length) for (e = 0; e < this.axisY2.length; e++)this.axisY2[e].crosshair && this.axisY2[e].crosshair.enabled && this.axisY2[e].renderCrosshair(a, d)
                            }
                        }; m.prototype._zoomPanToSelectedRegion = function (a, d, c, b, e) {
                            a = this.validateRegion(a, d, c, b, e); d = a.axesWithValidRange; c = a.axesRanges; if (a.isValid) for (b = 0; b < d.length; b++)e = c[b], d[b].setViewPortRange(e.val1,
                                e.val2), this.syncCharts && "y" != this.zoomType && this.syncCharts(e.val1, e.val2), this.stockChart && (this.stockChart._rangeEventParameter = { stockChart: this.stockChart, source: "chart", index: this.stockChart.charts.indexOf(this), minimum: e.val1, maximum: e.val2 }); return a.isValid
                        }; m.prototype.validateRegion = function (a, d, c, b, e) {
                            e = e || !1; for (var f = 0 <= this.zoomType.indexOf("x"), l = 0 <= this.zoomType.indexOf("y"), u = !1, A = [], k = [], n = [], p = 0; p < this._axes.length; p++)("axisX" === this._axes[p].type && f || "axisY" === this._axes[p].type &&
                                l) && k.push(this._axes[p]); for (l = 0; l < k.length; l++) {
                                    var p = k[l], f = !1, q = p.convertPixelToValue({ x: a, y: d }), g = p.convertPixelToValue({ x: c, y: b }); if (q > g) var r = g, g = q, q = r; if (p.scaleBreaks) for (r = 0; !f && r < p.scaleBreaks._appliedBreaks.length; r++)f = p.scaleBreaks._appliedBreaks[r].startValue <= q && p.scaleBreaks._appliedBreaks[r].endValue >= g; if (isFinite(p.dataInfo.minDiff)) if (r = p.getApparentDifference(q, g, null, !0), !(f || !(this.panEnabled && p.scaleBreaks && p.scaleBreaks._appliedBreaks.length) && (p.logarithmic && r < Math.pow(p.dataInfo.minDiff,
                                        3) || !p.logarithmic && r < 3 * Math.abs(p.dataInfo.minDiff)) || q < p.minimum || g > p.maximum)) A.push(p), n.push({ val1: q, val2: g }), u = !0; else if (!e) { u = !1; break }
                                } return { isValid: u, axesWithValidRange: A, axesRanges: n }
                        }; m.prototype.preparePlotArea = function () {
                            var a = this.plotArea; !v && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1); if ((this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {
                                var d = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates; if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {
                                    var c =
                                        this.axisY[0]; a.x1 = d.x1 < d.x2 ? d.x1 : c.lineCoordinates.x1; a.y1 = d.y1 < c.lineCoordinates.y1 ? d.y1 : c.lineCoordinates.y1; a.x2 = d.x2 > c.lineCoordinates.x2 ? d.x2 : c.lineCoordinates.x2; a.y2 = d.y2 > d.y1 ? d.y2 : c.lineCoordinates.y2; a.width = a.x2 - a.x1; a.height = a.y2 - a.y1
                                } this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (c = this.axisY2[0], a.x1 = d.x1 < d.x2 ? d.x1 : c.lineCoordinates.x1, a.y1 = d.y1 < c.lineCoordinates.y1 ? d.y1 : c.lineCoordinates.y1, a.x2 = d.x2 > c.lineCoordinates.x2 ? d.x2 : c.lineCoordinates.x2, a.y2 = d.y2 > d.y1 ? d.y2 : c.lineCoordinates.y2,
                                    a.width = a.x2 - a.x1, a.height = a.y2 - a.y1)
                            } else d = this.layoutManager.getFreeSpace(), a.x1 = d.x1, a.x2 = d.x2, a.y1 = d.y1, a.y2 = d.y2, a.width = d.width, a.height = d.height; v || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left = a.x1 + "px", a.canvas.style.top = a.y1 + "px", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(-a.x1, -a.y1)); a.layoutManager = new Ca(a.x1, a.y1, a.x2, a.y2, 2)
                        }; m.prototype.renderIndexLabels = function (a) {
                            var d = a || this.plotArea.ctx, c = this.plotArea, b = 0, e = 0, f = 0, l = f = e = 0, u = 0, A = b = 0, k = 0; for (a = 0; a < this._indexLabels.length; a++) {
                                var n =
                                    this._indexLabels[a], p = n.chartType.toLowerCase(), q, g, l = ka("indexLabelFontColor", n.dataPoint, n.dataSeries), r = ka("indexLabelFontSize", n.dataPoint, n.dataSeries), u = ka("indexLabelFontFamily", n.dataPoint, n.dataSeries), A = ka("indexLabelFontStyle", n.dataPoint, n.dataSeries), k = ka("indexLabelFontWeight", n.dataPoint, n.dataSeries), h = ka("indexLabelBackgroundColor", n.dataPoint, n.dataSeries); q = ka("indexLabelMaxWidth", n.dataPoint, n.dataSeries); g = ka("indexLabelWrap", n.dataPoint, n.dataSeries); var m = ka("indexLabelLineDashType",
                                        n.dataPoint, n.dataSeries), t = ka("indexLabelLineColor", n.dataPoint, n.dataSeries), x = s(n.dataPoint.indexLabelLineThickness) ? s(n.dataSeries.options.indexLabelLineThickness) ? 0 : n.dataSeries.options.indexLabelLineThickness : n.dataPoint.indexLabelLineThickness, b = 0 < x ? Math.min(10, ("normal" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0, z = { percent: null, total: null }, E = null; if (0 <= n.dataSeries.type.indexOf("stacked") || "pie" === n.dataSeries.type || "doughnut" === n.dataSeries.type) z = this.getPercentAndTotal(n.dataSeries,
                                            n.dataPoint); if (n.dataSeries.indexLabelFormatter || n.dataPoint.indexLabelFormatter) E = { chart: this, dataSeries: n.dataSeries, dataPoint: n.dataPoint, index: n.indexKeyword, total: z.total, percent: z.percent }; var C = n.dataPoint.indexLabelFormatter ? n.dataPoint.indexLabelFormatter(E) : n.dataPoint.indexLabel ? this.replaceKeywordsWithValue(n.dataPoint.indexLabel, n.dataPoint, n.dataSeries, null, n.indexKeyword) : n.dataSeries.indexLabelFormatter ? n.dataSeries.indexLabelFormatter(E) : n.dataSeries.indexLabel ? this.replaceKeywordsWithValue(n.dataSeries.indexLabel,
                                                n.dataPoint, n.dataSeries, null, n.indexKeyword) : null; if (null !== C && "" !== C) {
                                                    var z = ka("indexLabelPlacement", n.dataPoint, n.dataSeries), E = ka("indexLabelOrientation", n.dataPoint, n.dataSeries), B = n.direction, e = n.dataSeries.axisX, f = n.dataSeries.axisY, w = !1, h = new ia(d, { x: 0, y: 0, maxWidth: q ? q : 0.5 * this.width, maxHeight: g ? 5 * r : 1.5 * r, angle: "horizontal" === E ? 0 : -90, text: C, padding: 0, backgroundColor: h, horizontalAlign: "left", fontSize: r, fontFamily: u, fontWeight: k, fontColor: l, fontStyle: A, textBaseline: "middle" }); h.measureText();
                                                    n.dataSeries.indexLabelMaxWidth = h.maxWidth; if ("stackedarea100" === p) { if (n.point.x < c.x1 || n.point.x > c.x2 || n.point.y < c.y1 - 1 || n.point.y > c.y2 + 1) continue } else if ("rangearea" === p || "rangesplinearea" === p) { if (n.dataPoint.x < e.viewportMinimum || n.dataPoint.x > e.viewportMaximum || Math.max.apply(null, n.dataPoint.y) < f.viewportMinimum || Math.min.apply(null, n.dataPoint.y) > f.viewportMaximum) continue } else if (0 <= p.indexOf("line") || 0 <= p.indexOf("area") || 0 <= p.indexOf("bubble") || 0 <= p.indexOf("scatter")) {
                                                        if (n.dataPoint.x < e.viewportMinimum ||
                                                            n.dataPoint.x > e.viewportMaximum || n.dataPoint.y < f.viewportMinimum || n.dataPoint.y > f.viewportMaximum) continue
                                                    } else if (0 <= p.indexOf("column") || "waterfall" === p || "error" === p && !n.axisSwapped) { if (n.dataPoint.x < e.viewportMinimum || n.dataPoint.x > e.viewportMaximum || n.bounds.y1 > c.y2 || n.bounds.y2 < c.y1) continue } else if (0 <= p.indexOf("bar") || "error" === p) { if (n.dataPoint.x < e.viewportMinimum || n.dataPoint.x > e.viewportMaximum || n.bounds.x1 > c.x2 || n.bounds.x2 < c.x1) continue } else if ("candlestick" === p || "ohlc" === p) {
                                                        if (n.dataPoint.x <
                                                            e.viewportMinimum || n.dataPoint.x > e.viewportMaximum || Math.max.apply(null, n.dataPoint.y) < f.viewportMinimum || Math.min.apply(null, n.dataPoint.y) > f.viewportMaximum) continue
                                                    } else if (n.dataPoint.x < e.viewportMinimum || n.dataPoint.x > e.viewportMaximum) continue; l = u = 2; "horizontal" === E ? (A = h.width, k = h.height) : (k = h.width, A = h.height); if ("normal" === this.plotInfo.axisPlacement) {
                                                        if (0 <= p.indexOf("line") || 0 <= p.indexOf("area")) z = "auto", u = 4; else if (0 <= p.indexOf("stacked")) "auto" === z && (z = "inside"); else if ("bubble" === p || "scatter" ===
                                                            p) z = "inside"; q = n.point.x - ("horizontal" === E ? A / 2 : A / 2 - r / 2); "inside" !== z ? (e = c.y1, f = c.y2, 0 < B ? (g = n.point.y + ("horizontal" === E ? r / 2 : 0) - k - u - b, g < e && (g = "auto" === z ? Math.max(n.point.y, e) + r / 2 + u : e + r / 2 + u, w = g + k > n.point.y)) : (g = n.point.y + r / 2 + u + b, g > f - k && (g = "auto" === z ? Math.min(n.point.y, f) + r / 2 - k - u : f + r / 2 - k, w = g < n.point.y))) : (e = Math.max(n.bounds.y1, c.y1), f = Math.min(n.bounds.y2, c.y2 - k + r / 2), b = 0 <= p.indexOf("range") || "error" === p ? 0 < B ? Math.max(n.bounds.y1, c.y1) + r / 2 + u : Math.min(n.bounds.y2, c.y2) + r / 2 - k + u : (Math.max(n.bounds.y1, c.y1) +
                                                                Math.min(n.bounds.y2, c.y2)) / 2 - k / 2 + r / 2 + ("horizontal" === E ? u : 0), 0 < B ? (g = Math.max(n.point.y, b), g < e && ("bubble" === p || "scatter" === p) && (g = Math.max(n.point.y - k - u, c.y1 + u))) : (g = Math.min(n.point.y, b), g > f - k - u && ("bubble" === p || "scatter" === p) && (g = Math.min(n.point.y + u, c.y2 - k - u))), g = Math.min(g, f))
                                                    } else 0 <= p.indexOf("line") || 0 <= p.indexOf("area") || 0 <= p.indexOf("scatter") ? (z = "auto", l = 4) : 0 <= p.indexOf("stacked") ? "auto" === z && (z = "inside") : "bubble" === p && (z = "inside"), g = n.point.y + r / 2 - k / 2 + u, "inside" !== z ? (e = c.x1, f = c.x2, 0 > B ? (q =
                                                        n.point.x - ("horizontal" === E ? A : A - r / 2) - l - b, q < e && (q = "auto" === z ? Math.max(n.point.x, e) + l : e + l, w = q + A > n.point.x)) : (q = n.point.x + ("horizontal" === E ? 0 : r / 2) + l + b, q > f - A - l - b && (q = "auto" === z ? Math.min(n.point.x, f) - ("horizontal" === E ? A : A / 2) - l : f - A - l, w = q < n.point.x))) : (e = Math.max(n.bounds.x1, c.x1), Math.min(n.bounds.x2, c.x2), b = 0 <= p.indexOf("range") || "error" === p ? 0 > B ? Math.max(n.bounds.x1, c.x1) + r / 2 + l : Math.min(n.bounds.x2, c.x2) - A / 2 - l + ("horizontal" === E ? 0 : r / 2) : (Math.max(n.bounds.x1, c.x1) + Math.min(n.bounds.x2, c.x2)) / 2 + ("horizontal" ===
                                                            E ? 0 : r / 2), q = 0 > B ? Math.max(n.point.x, b) - ("horizontal" === E ? A / 2 : 0) : Math.min(n.point.x, b) - A / 2, q = Math.max(q, e)); "vertical" === E && (g += k - r / 2); h.x = q; h.y = g; h.render(!0); x && ("inside" !== z && (0 > p.indexOf("bar") && ("error" !== p || !n.axisSwapped) && n.point.x > c.x1 && n.point.x < c.x2 || !w) && (0 > p.indexOf("column") && ("error" !== p || n.axisSwapped) && n.point.y > c.y1 && n.point.y < c.y2 || !w)) && (d.lineWidth = x, d.strokeStyle = t ? t : "gray", d.setLineDash && d.setLineDash(N(m, x)), d.beginPath(), d.moveTo(n.point.x, n.point.y), 0 <= p.indexOf("bar") || "error" ===
                                                                p && n.axisSwapped ? d.lineTo(q + (0 < n.direction ? -l : A + l) + ("vertical" === E ? -r / 2 : 0), g + ("vertical" === E ? -k / 2 : k / 2 - r / 2) - u) : 0 <= p.indexOf("column") || "error" === p && !n.axisSwapped ? d.lineTo(q + A / 2 - ("horizontal" === E ? 0 : r / 2), g + ("vertical" === E ? (g - k < n.point.y ? 0 : -k) + u : (g - r / 2 < n.point.y ? k : 0) - r / 2)) : d.lineTo(q + A / 2 - ("horizontal" === E ? 0 : r / 2), g + ("vertical" === E ? g - k < n.point.y ? 0 : -k : (g - r / 2 < n.point.y ? k : 0) - r / 2)), d.stroke())
                                                }
                            } d = {
                                source: d, dest: this.plotArea.ctx, animationCallback: L.fadeInAnimation, easingFunction: L.easing.easeInQuad, animationBase: 0,
                                startTimePercent: 0.7
                            }; for (a = 0; a < this._indexLabels.length; a++)n = this._indexLabels[a], h = ka("indexLabelBackgroundColor", n.dataPoint, n.dataSeries), n.dataSeries.indexLabelBackgroundColor = s(h) ? v ? "transparent" : null : h; return d
                        }; m.prototype.renderLine = function (a) {
                            var d = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                                var b = this._eventManager.ghostCtx; c.save(); var e = this.plotArea; c.beginPath(); c.rect(e.x1, e.y1, e.width, e.height); c.clip(); for (var f = [], l, u = 0; u <
                                    a.dataSeriesIndexes.length; u++) {
                                        var A = a.dataSeriesIndexes[u], k = this.data[A]; c.lineWidth = k.lineThickness; var n = k.dataPoints, p = "solid"; if (c.setLineDash) { var q = N(k.nullDataLineDashType, k.lineThickness), p = k.lineDashType, g = N(p, k.lineThickness); c.setLineDash(g) } var r = k.id; this._eventManager.objectMap[r] = { objectType: "dataSeries", dataSeriesIndex: A }; r = Q(r); b.strokeStyle = r; b.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0; var r = k._colorSet, h = r = k.lineColor = k.options.lineColor ? k.options.lineColor : r[0];
                                    c.strokeStyle = r; var m = !0, t = 0, x, s; c.beginPath(); if (0 < n.length) {
                                        for (var E = !1, t = 0; t < n.length; t++)if (x = n[t].x.getTime ? n[t].x.getTime() : n[t].x, !(x < a.axisX.dataInfo.viewPortMin || x > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !E))) if ("number" !== typeof n[t].y) 0 < t && !(k.connectNullData || E || m) && (c.stroke(), v && b.stroke()), E = !0; else {
                                            x = a.axisX.convertValueToPixel(x); s = a.axisY.convertValueToPixel(n[t].y); var C = k.dataPointIds[t]; this._eventManager.objectMap[C] = {
                                                id: C, objectType: "dataPoint", dataSeriesIndex: A,
                                                dataPointIndex: t, x1: x, y1: s
                                            }; m || E ? (!m && k.connectNullData ? (c.setLineDash && (k.options.nullDataLineDashType || p === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (c.stroke(), c.beginPath(), c.moveTo(l.x, l.y), p = k.nullDataLineDashType, c.setLineDash(q)), c.lineTo(x, s), v && b.lineTo(x, s)) : (c.beginPath(), c.moveTo(x, s), v && (b.beginPath(), b.moveTo(x, s))), E = m = !1) : (c.lineTo(x, s), v && b.lineTo(x, s), 0 == t % 500 && (c.stroke(), c.beginPath(), c.moveTo(x, s), v && (b.stroke(), b.beginPath(), b.moveTo(x, s)))); l = { x: x, y: s }; t < n.length -
                                                1 && (h !== (n[t].lineColor || r) || p !== (n[t].lineDashType || k.lineDashType)) && (c.stroke(), c.beginPath(), c.moveTo(x, s), h = n[t].lineColor || r, c.strokeStyle = h, c.setLineDash && (n[t].lineDashType ? (p = n[t].lineDashType, c.setLineDash(N(p, k.lineThickness))) : (p = k.lineDashType, c.setLineDash(g)))); if (0 < n[t].markerSize || 0 < k.markerSize) { var B = k.getMarkerProperties(t, x, s, c); f.push(B); C = Q(C); v && f.push({ x: x, y: s, ctx: b, type: B.type, size: B.size, color: C, borderColor: C, borderThickness: B.borderThickness }) } (n[t].indexLabel || k.indexLabel ||
                                                    n[t].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "line", dataPoint: n[t], dataSeries: k, point: { x: x, y: s }, direction: 0 > n[t].y === a.axisY.reversed ? 1 : -1, color: r })
                                        } c.stroke(); v && b.stroke()
                                    }
                                } W.drawMarkers(f); v && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx &&
                                    this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(e.x1, e.y1, e.width, e.height), b.beginPath()); c.restore(); c.beginPath(); return { source: d, dest: this.plotArea.ctx, animationCallback: L.xClipAnimation, easingFunction: L.easing.linear, animationBase: 0 }
                            }
                        }; m.prototype.renderStepLine = function (a) {
                            var d = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                                var b = this._eventManager.ghostCtx; c.save(); var e = this.plotArea; c.beginPath();
                                c.rect(e.x1, e.y1, e.width, e.height); c.clip(); for (var f = [], l, u = 0; u < a.dataSeriesIndexes.length; u++) {
                                    var A = a.dataSeriesIndexes[u], k = this.data[A]; c.lineWidth = k.lineThickness; var n = k.dataPoints, p = "solid"; if (c.setLineDash) { var q = N(k.nullDataLineDashType, k.lineThickness), p = k.lineDashType, g = N(p, k.lineThickness); c.setLineDash(g) } var r = k.id; this._eventManager.objectMap[r] = { objectType: "dataSeries", dataSeriesIndex: A }; r = Q(r); b.strokeStyle = r; b.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0; var r = k._colorSet,
                                        h = r = k.lineColor = k.options.lineColor ? k.options.lineColor : r[0]; c.strokeStyle = r; var m = !0, t = 0, x, s; c.beginPath(); if (0 < n.length) {
                                            for (var E = !1, t = 0; t < n.length; t++)if (x = n[t].getTime ? n[t].x.getTime() : n[t].x, !(x < a.axisX.dataInfo.viewPortMin || x > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !E))) if ("number" !== typeof n[t].y) 0 < t && !(k.connectNullData || E || m) && (c.stroke(), v && b.stroke()), E = !0; else {
                                                var C = s; x = a.axisX.convertValueToPixel(x); s = a.axisY.convertValueToPixel(n[t].y); var B = k.dataPointIds[t]; this._eventManager.objectMap[B] =
                                                    { id: B, objectType: "dataPoint", dataSeriesIndex: A, dataPointIndex: t, x1: x, y1: s }; m || E ? (!m && k.connectNullData ? (c.setLineDash && (k.options.nullDataLineDashType || p === k.lineDashType && k.lineDashType !== k.nullDataLineDashType) && (c.stroke(), c.beginPath(), c.moveTo(l.x, l.y), p = k.nullDataLineDashType, c.setLineDash(q)), c.lineTo(x, C), c.lineTo(x, s), v && (b.lineTo(x, C), b.lineTo(x, s))) : (c.beginPath(), c.moveTo(x, s), v && (b.beginPath(), b.moveTo(x, s))), E = m = !1) : (c.lineTo(x, C), v && b.lineTo(x, C), c.lineTo(x, s), v && b.lineTo(x, s), 0 == t %
                                                        500 && (c.stroke(), c.beginPath(), c.moveTo(x, s), v && (b.stroke(), b.beginPath(), b.moveTo(x, s)))); l = { x: x, y: s }; t < n.length - 1 && (h !== (n[t].lineColor || r) || p !== (n[t].lineDashType || k.lineDashType)) && (c.stroke(), c.beginPath(), c.moveTo(x, s), h = n[t].lineColor || r, c.strokeStyle = h, c.setLineDash && (n[t].lineDashType ? (p = n[t].lineDashType, c.setLineDash(N(p, k.lineThickness))) : (p = k.lineDashType, c.setLineDash(g)))); if (0 < n[t].markerSize || 0 < k.markerSize) C = k.getMarkerProperties(t, x, s, c), f.push(C), B = Q(B), v && f.push({
                                                            x: x, y: s, ctx: b,
                                                            type: C.type, size: C.size, color: B, borderColor: B, borderThickness: C.borderThickness
                                                        }); (n[t].indexLabel || k.indexLabel || n[t].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepLine", dataPoint: n[t], dataSeries: k, point: { x: x, y: s }, direction: 0 > n[t].y === a.axisY.reversed ? 1 : -1, color: r })
                                            } c.stroke(); v && b.stroke()
                                        }
                                } W.drawMarkers(f); v && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas,
                                    0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(e.x1, e.y1, e.width, e.height), b.beginPath()); c.restore(); c.beginPath(); return { source: d, dest: this.plotArea.ctx, animationCallback: L.xClipAnimation, easingFunction: L.easing.linear, animationBase: 0 }
                            }
                        }; m.prototype.renderSpline = function (a) {
                            function d(a) {
                                a = w(a, 2); if (0 < a.length) {
                                    b.beginPath();
                                    v && e.beginPath(); b.moveTo(a[0].x, a[0].y); a[0].newStrokeStyle && (b.strokeStyle = a[0].newStrokeStyle); a[0].newLineDashArray && b.setLineDash(a[0].newLineDashArray); v && e.moveTo(a[0].x, a[0].y); for (var c = 0; c < a.length - 3; c += 3)if (b.bezierCurveTo(a[c + 1].x, a[c + 1].y, a[c + 2].x, a[c + 2].y, a[c + 3].x, a[c + 3].y), v && e.bezierCurveTo(a[c + 1].x, a[c + 1].y, a[c + 2].x, a[c + 2].y, a[c + 3].x, a[c + 3].y), 0 < c && 0 === c % 3E3 || a[c + 3].newStrokeStyle || a[c + 3].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(a[c + 3].x, a[c + 3].y), a[c + 3].newStrokeStyle &&
                                        (b.strokeStyle = a[c + 3].newStrokeStyle), a[c + 3].newLineDashArray && b.setLineDash(a[c + 3].newLineDashArray), v && (e.stroke(), e.beginPath(), e.moveTo(a[c + 3].x, a[c + 3].y)); b.stroke(); v && e.stroke()
                                }
                            } var c = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : c; if (!(0 >= a.dataSeriesIndexes.length)) {
                                var e = this._eventManager.ghostCtx; b.save(); var f = this.plotArea; b.beginPath(); b.rect(f.x1, f.y1, f.width, f.height); b.clip(); for (var l = [], u = 0; u < a.dataSeriesIndexes.length; u++) {
                                    var A = a.dataSeriesIndexes[u], k = this.data[A];
                                    b.lineWidth = k.lineThickness; var n = k.dataPoints, p = "solid"; if (b.setLineDash) { var q = N(k.nullDataLineDashType, k.lineThickness), p = k.lineDashType, g = N(p, k.lineThickness); b.setLineDash(g) } var r = k.id; this._eventManager.objectMap[r] = { objectType: "dataSeries", dataSeriesIndex: A }; r = Q(r); e.strokeStyle = r; e.lineWidth = 0 < k.lineThickness ? Math.max(k.lineThickness, 4) : 0; var r = k._colorSet, h = r = k.lineColor = k.options.lineColor ? k.options.lineColor : r[0]; b.strokeStyle = r; var m = 0, t, x, s = []; b.beginPath(); if (0 < n.length) for (x = !1, m =
                                        0; m < n.length; m++)if (t = n[m].getTime ? n[m].x.getTime() : n[m].x, !(t < a.axisX.dataInfo.viewPortMin || t > a.axisX.dataInfo.viewPortMax && (!k.connectNullData || !x))) if ("number" !== typeof n[m].y) 0 < m && !x && (k.connectNullData ? b.setLineDash && (0 < s.length && (k.options.nullDataLineDashType || !n[m - 1].lineDashType)) && (s[s.length - 1].newLineDashArray = q, p = k.nullDataLineDashType) : (d(s), s = [])), x = !0; else {
                                            t = a.axisX.convertValueToPixel(t); x = a.axisY.convertValueToPixel(n[m].y); var E = k.dataPointIds[m]; this._eventManager.objectMap[E] =
                                                { id: E, objectType: "dataPoint", dataSeriesIndex: A, dataPointIndex: m, x1: t, y1: x }; s[s.length] = { x: t, y: x }; m < n.length - 1 && (h !== (n[m].lineColor || r) || p !== (n[m].lineDashType || k.lineDashType)) && (h = n[m].lineColor || r, s[s.length - 1].newStrokeStyle = h, b.setLineDash && (n[m].lineDashType ? (p = n[m].lineDashType, s[s.length - 1].newLineDashArray = N(p, k.lineThickness)) : (p = k.lineDashType, s[s.length - 1].newLineDashArray = g))); if (0 < n[m].markerSize || 0 < k.markerSize) {
                                                    var C = k.getMarkerProperties(m, t, x, b); l.push(C); E = Q(E); v && l.push({
                                                        x: t, y: x,
                                                        ctx: e, type: C.type, size: C.size, color: E, borderColor: E, borderThickness: C.borderThickness
                                                    })
                                                } (n[m].indexLabel || k.indexLabel || n[m].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "spline", dataPoint: n[m], dataSeries: k, point: { x: t, y: x }, direction: 0 > n[m].y === a.axisY.reversed ? 1 : -1, color: r }); x = !1
                                        } d(s)
                                } W.drawMarkers(l); v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width,
                                    this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(f.x1, f.y1, f.width, f.height), e.beginPath()); b.restore(); b.beginPath(); return { source: c, dest: this.plotArea.ctx, animationCallback: L.xClipAnimation, easingFunction: L.easing.linear, animationBase: 0 }
                            }
                        }; m.prototype.renderColumn = function (a) {
                            var d = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx :
                                d; if (!(0 >= a.dataSeriesIndexes.length)) {
                                    var b = null, e = this.plotArea, f = 0, l, u, A, k = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, n = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.width, 0.9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0, p = a.axisX.dataInfo.minDiff; isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range));
                                    p = this.dataPointWidth = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) : Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0; this.dataPointMaxWidth && f > n && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, n)); !this.dataPointMaxWidth && (this.dataPointMinWidth && n < f) && (n = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f)); p < f && (p = f); p > n && (p = n); c.save(); v && this._eventManager.ghostCtx.save();
                                    c.beginPath(); c.rect(e.x1, e.y1, e.width, e.height); c.clip(); v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (n = 0; n < a.dataSeriesIndexes.length; n++) {
                                        var q = a.dataSeriesIndexes[n], g = this.data[q], r = g.dataPoints; if (0 < r.length) for (var h = 5 < p && g.bevelEnabled ? !0 : !1, f = 0; f < r.length; f++)if (r[f].getTime ? A = r[f].x.getTime() : A = r[f].x, !(A < a.axisX.dataInfo.viewPortMin || A > a.axisX.dataInfo.viewPortMax) && "number" === typeof r[f].y) {
                                            l =
                                            a.axisX.convertValueToPixel(A); u = a.axisY.convertValueToPixel(r[f].y); l = a.axisX.reversed ? l + a.plotType.totalDataSeries * p / 2 - (a.previousDataSeriesCount + n) * p << 0 : l - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + n) * p << 0; var m = a.axisX.reversed ? l - p << 0 : l + p << 0, t; 0 <= r[f].y ? t = k : (t = u, u = k); u > t && (b = u, u = t, t = b); b = r[f].color ? r[f].color : g._colorSet[f % g._colorSet.length]; ca(c, l, u, m, t, b, 0, null, h && 0 <= r[f].y, 0 > r[f].y && h, !1, !1, g.fillOpacity); b = g.dataPointIds[f]; this._eventManager.objectMap[b] = {
                                                id: b, objectType: "dataPoint",
                                                dataSeriesIndex: q, dataPointIndex: f, x1: l, y1: u, x2: m, y2: t
                                            }; b = Q(b); v && ca(this._eventManager.ghostCtx, l, u, m, t, b, 0, null, !1, !1, !1, !1); (r[f].indexLabel || g.indexLabel || r[f].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "column", dataPoint: r[f], dataSeries: g, point: { x: l + (m - l) / 2, y: 0 > r[f].y === a.axisY.reversed ? u : t }, direction: 0 > r[f].y === a.axisY.reversed ? 1 : -1, bounds: { x1: l, y1: Math.min(u, t), x2: m, y2: Math.max(u, t) }, color: b })
                                        }
                                    } v && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height),
                                        c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore()); c.restore(); return {
                                            source: d, dest: this.plotArea.ctx, animationCallback: L.yScaleAnimation, easingFunction: L.easing.easeOutQuart,
                                            animationBase: k < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : k > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : k
                                        }
                                }
                        }; m.prototype.renderStackedColumn = function (a) {
                            var d = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                                var b = null, e = this.plotArea, f = [], l = [], u = [], A = [], k = 0, n, p, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; n = this.options.dataPointMaxWidth ?
                                    this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0; var g = a.axisX.dataInfo.minDiff; isFinite(g) || (g = 0.3 * Math.abs(a.axisX.range)); g = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(g) / Math.log(a.axisX.range) : Math.abs(g) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0; this.dataPointMaxWidth && k > n && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, n)); !this.dataPointMaxWidth && (this.dataPointMinWidth &&
                                        n < k) && (n = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k)); g < k && (g = k); g > n && (g = n); c.save(); v && this._eventManager.ghostCtx.save(); c.beginPath(); c.rect(e.x1, e.y1, e.width, e.height); c.clip(); v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (var r = 0; r < a.dataSeriesIndexes.length; r++) {
                                            var h = a.dataSeriesIndexes[r], m = this.data[h], t = m.dataPoints; if (0 < t.length) {
                                                var x = 5 < g && m.bevelEnabled ? !0 : !1; c.strokeStyle =
                                                    "#4572A7 "; for (k = 0; k < t.length; k++)if (b = t[k].x.getTime ? t[k].x.getTime() : t[k].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[k].y) {
                                                        n = a.axisX.convertValueToPixel(b); var s = n - a.plotType.plotUnits.length * g / 2 + a.index * g << 0, E = s + g << 0, C; if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[k].y) u[b] = t[k].y + (u[b] ? u[b] : 0), 0 < u[b] && (p = a.axisY.convertValueToPixel(u[b]), C = "undefined" !== typeof f[b] ? f[b] : q, f[b] = p); else if (a.axisY.scaleBreaks &&
                                                            0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[k].y) A[b] = t[k].y + (A[b] ? A[b] : 0), C = a.axisY.convertValueToPixel(A[b]), p = "undefined" !== typeof l[b] ? l[b] : q, l[b] = C; else if (p = a.axisY.convertValueToPixel(t[k].y), 0 <= t[k].y) { var B = "undefined" !== typeof f[b] ? f[b] : 0; p -= B; C = q - B; f[b] = B + (C - p) } else B = l[b] ? l[b] : 0, C = p + B, p = q + B, l[b] = B + (C - p); b = t[k].color ? t[k].color : m._colorSet[k % m._colorSet.length]; ca(c, s, p, E, C, b, 0, null, x && 0 <= t[k].y, 0 > t[k].y && x, !1, !1, m.fillOpacity); b = m.dataPointIds[k]; this._eventManager.objectMap[b] =
                                                                { id: b, objectType: "dataPoint", dataSeriesIndex: h, dataPointIndex: k, x1: s, y1: p, x2: E, y2: C }; b = Q(b); v && ca(this._eventManager.ghostCtx, s, p, E, C, b, 0, null, !1, !1, !1, !1); (t[k].indexLabel || m.indexLabel || t[k].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedColumn", dataPoint: t[k], dataSeries: m, point: { x: n, y: 0 <= t[k].y ? p : C }, direction: 0 > t[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: s, y1: Math.min(p, C), x2: E, y2: Math.max(p, C) }, color: b })
                                                    }
                                            }
                                        } v && (d.drawImage(this._preRenderCanvas, 0, 0, this.width,
                                            this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore()); c.restore(); return {
                                                source: d, dest: this.plotArea.ctx, animationCallback: L.yScaleAnimation, easingFunction: L.easing.easeOutQuart,
                                                animationBase: q < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : q > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : q
                                            }
                            }
                        }; m.prototype.renderStackedColumn100 = function (a) {
                            var d = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                                var b = null, e = this.plotArea, f = [], l = [], u = [], A = [], k = 0, n, p, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; n = this.options.dataPointMaxWidth ?
                                    this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.width << 0; var g = a.axisX.dataInfo.minDiff; isFinite(g) || (g = 0.3 * Math.abs(a.axisX.range)); g = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.width * (a.axisX.logarithmic ? Math.log(g) / Math.log(a.axisX.range) : Math.abs(g) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0; this.dataPointMaxWidth && k > n && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, n)); !this.dataPointMaxWidth && (this.dataPointMinWidth &&
                                        n < k) && (n = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k)); g < k && (g = k); g > n && (g = n); c.save(); v && this._eventManager.ghostCtx.save(); c.beginPath(); c.rect(e.x1, e.y1, e.width, e.height); c.clip(); v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (var r = 0; r < a.dataSeriesIndexes.length; r++) {
                                            var h = a.dataSeriesIndexes[r], m = this.data[h], t = m.dataPoints; if (0 < t.length) for (var x = 5 < g && m.bevelEnabled ? !0 : !1,
                                                k = 0; k < t.length; k++)if (b = t[k].x.getTime ? t[k].x.getTime() : t[k].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[k].y) {
                                                    n = a.axisX.convertValueToPixel(b); p = 0 !== a.dataPointYSums[b] ? 100 * (t[k].y / a.dataPointYSums[b]) : 0; var s = n - a.plotType.plotUnits.length * g / 2 + a.index * g << 0, E = s + g << 0, C; if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[k].y) {
                                                        u[b] = p + ("undefined" !== typeof u[b] ? u[b] : 0); if (0 >= u[b]) continue; p = a.axisY.convertValueToPixel(u[b]);
                                                        C = f[b] ? f[b] : q; f[b] = p
                                                    } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[k].y) A[b] = p + ("undefined" !== typeof A[b] ? A[b] : 0), C = a.axisY.convertValueToPixel(A[b]), p = l[b] ? l[b] : q, l[b] = C; else if (p = a.axisY.convertValueToPixel(p), 0 <= t[k].y) { var B = "undefined" !== typeof f[b] ? f[b] : 0; p -= B; C = q - B; a.dataSeriesIndexes.length - 1 === r && 1 >= Math.abs(e.y1 - p) && (p = e.y1); f[b] = B + (C - p) } else B = "undefined" !== typeof l[b] ? l[b] : 0, C = p + B, p = q + B, a.dataSeriesIndexes.length - 1 === r && 1 >= Math.abs(e.y2 - C) && (C = e.y2), l[b] =
                                                        B + (C - p); b = t[k].color ? t[k].color : m._colorSet[k % m._colorSet.length]; ca(c, s, p, E, C, b, 0, null, x && 0 <= t[k].y, 0 > t[k].y && x, !1, !1, m.fillOpacity); b = m.dataPointIds[k]; this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: h, dataPointIndex: k, x1: s, y1: p, x2: E, y2: C }; b = Q(b); v && ca(this._eventManager.ghostCtx, s, p, E, C, b, 0, null, !1, !1, !1, !1); (t[k].indexLabel || m.indexLabel || t[k].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({
                                                            chartType: "stackedColumn100", dataPoint: t[k], dataSeries: m,
                                                            point: { x: n, y: 0 <= t[k].y ? p : C }, direction: 0 > t[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: s, y1: Math.min(p, C), x2: E, y2: Math.max(p, C) }, color: b
                                                        })
                                                }
                                        } v && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height),
                                            c.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore()); c.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: L.yScaleAnimation, easingFunction: L.easing.easeOutQuart, animationBase: q < a.axisY.bounds.y1 ? a.axisY.bounds.y1 : q > a.axisY.bounds.y2 ? a.axisY.bounds.y2 : q }
                            }
                        }; m.prototype.renderBar = function (a) {
                            var d = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                                var b = null, e = this.plotArea, f = 0, l, u, A, k = a.axisY.convertValueToPixel(a.axisY.logarithmic ?
                                    a.axisY.viewportMinimum : 0), f = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, n = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(0.15 * this.height, 0.9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0, p = a.axisX.dataInfo.minDiff; isFinite(p) || (p = 0.3 * Math.abs(a.axisX.range)); p = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(p) / Math.log(a.axisX.range) :
                                        Math.abs(p) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0; this.dataPointMaxWidth && f > n && (f = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, n)); !this.dataPointMaxWidth && (this.dataPointMinWidth && n < f) && (n = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, f)); p < f && (p = f); p > n && (p = n); c.save(); v && this._eventManager.ghostCtx.save(); c.beginPath(); c.rect(e.x1, e.y1, e.width, e.height); c.clip(); v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1,
                                            e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (n = 0; n < a.dataSeriesIndexes.length; n++) {
                                                var q = a.dataSeriesIndexes[n], g = this.data[q], r = g.dataPoints; if (0 < r.length) {
                                                    var h = 5 < p && g.bevelEnabled ? !0 : !1; c.strokeStyle = "#4572A7 "; for (f = 0; f < r.length; f++)if (r[f].getTime ? A = r[f].x.getTime() : A = r[f].x, !(A < a.axisX.dataInfo.viewPortMin || A > a.axisX.dataInfo.viewPortMax) && "number" === typeof r[f].y) {
                                                        u = a.axisX.convertValueToPixel(A); l = a.axisY.convertValueToPixel(r[f].y); u = a.axisX.reversed ? u + a.plotType.totalDataSeries *
                                                            p / 2 - (a.previousDataSeriesCount + n) * p << 0 : u - a.plotType.totalDataSeries * p / 2 + (a.previousDataSeriesCount + n) * p << 0; var m = a.axisX.reversed ? u - p << 0 : u + p << 0, t; 0 <= r[f].y ? t = k : (t = l, l = k); b = r[f].color ? r[f].color : g._colorSet[f % g._colorSet.length]; ca(c, t, u, l, m, b, 0, null, h, !1, !1, !1, g.fillOpacity); b = g.dataPointIds[f]; this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: f, x1: t, y1: u, x2: l, y2: m }; b = Q(b); v && ca(this._eventManager.ghostCtx, t, u, l, m, b, 0, null, !1, !1, !1, !1); (r[f].indexLabel ||
                                                                g.indexLabel || r[f].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "bar", dataPoint: r[f], dataSeries: g, point: { x: 0 <= r[f].y ? l : t, y: u + (m - u) / 2 }, direction: 0 > r[f].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(t, l), y1: u, x2: Math.max(t, l), y2: m }, color: b })
                                                    }
                                                }
                                            } v && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas,
                                                0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore()); c.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: L.xScaleAnimation, easingFunction: L.easing.easeOutQuart, animationBase: k < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : k > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : k }
                            }
                        }; m.prototype.renderStackedBar = function (a) {
                            var d = a.targetCanvasCtx || this.plotArea.ctx,
                            c = v ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                                var b = null, e = this.plotArea, f = [], l = [], u = [], A = [], k = 0, n, p, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; p = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0; var g = a.axisX.dataInfo.minDiff; isFinite(g) || (g = 0.3 * Math.abs(a.axisX.range)); g =
                                    this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(g) / Math.log(a.axisX.range) : Math.abs(g) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0; this.dataPointMaxWidth && k > p && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, p)); !this.dataPointMaxWidth && (this.dataPointMinWidth && p < k) && (p = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k)); g < k && (g = k); g > p && (g = p); c.save(); v && this._eventManager.ghostCtx.save(); c.beginPath();
                                c.rect(e.x1, e.y1, e.width, e.height); c.clip(); v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (var r = 0; r < a.dataSeriesIndexes.length; r++) {
                                    var h = a.dataSeriesIndexes[r], m = this.data[h], t = m.dataPoints; if (0 < t.length) {
                                        var x = 5 < g && m.bevelEnabled ? !0 : !1; c.strokeStyle = "#4572A7 "; for (k = 0; k < t.length; k++)if (b = t[k].x.getTime ? t[k].x.getTime() : t[k].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" ===
                                            typeof t[k].y) {
                                                p = a.axisX.convertValueToPixel(b); var s = p - a.plotType.plotUnits.length * g / 2 + a.index * g << 0, E = s + g << 0, C; if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[k].y) u[b] = t[k].y + (u[b] ? u[b] : 0), 0 < u[b] && (C = f[b] ? f[b] : q, f[b] = n = a.axisY.convertValueToPixel(u[b])); else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[k].y) A[b] = t[k].y + (A[b] ? A[b] : 0), n = l[b] ? l[b] : q, l[b] = C = a.axisY.convertValueToPixel(A[b]); else if (n = a.axisY.convertValueToPixel(t[k].y),
                                                    0 <= t[k].y) { var B = f[b] ? f[b] : 0; C = q + B; n += B; f[b] = B + (n - C) } else B = l[b] ? l[b] : 0, C = n - B, n = q - B, l[b] = B + (n - C); b = t[k].color ? t[k].color : m._colorSet[k % m._colorSet.length]; ca(c, C, s, n, E, b, 0, null, x, !1, !1, !1, m.fillOpacity); b = m.dataPointIds[k]; this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: h, dataPointIndex: k, x1: C, y1: s, x2: n, y2: E }; b = Q(b); v && ca(this._eventManager.ghostCtx, C, s, n, E, b, 0, null, !1, !1, !1, !1); (t[k].indexLabel || m.indexLabel || t[k].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({
                                                        chartType: "stackedBar",
                                                        dataPoint: t[k], dataSeries: m, point: { x: 0 <= t[k].y ? n : C, y: p }, direction: 0 > t[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(C, n), y1: s, x2: Math.max(C, n), y2: E }, color: b
                                                    })
                                        }
                                    }
                                } v && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas,
                                    0, 0, this.width, this.height), c.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore()); c.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: L.xScaleAnimation, easingFunction: L.easing.easeOutQuart, animationBase: q < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : q > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : q }
                            }
                        }; m.prototype.renderStackedBar100 = function (a) {
                            var d = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                                var b = null, e = this.plotArea,
                                f = [], l = [], u = [], A = [], k = 0, n, p, q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), k = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1; p = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.15 * this.height << 0; var g = a.axisX.dataInfo.minDiff; isFinite(g) || (g = 0.3 * Math.abs(a.axisX.range)); g = this.options.dataPointWidth ? this.dataPointWidth : 0.9 * (e.height * (a.axisX.logarithmic ? Math.log(g) /
                                    Math.log(a.axisX.range) : Math.abs(g) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0; this.dataPointMaxWidth && k > p && (k = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, p)); !this.dataPointMaxWidth && (this.dataPointMinWidth && p < k) && (p = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, k)); g < k && (g = k); g > p && (g = p); c.save(); v && this._eventManager.ghostCtx.save(); c.beginPath(); c.rect(e.x1, e.y1, e.width, e.height); c.clip(); v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(e.x1,
                                        e.y1, e.width, e.height), this._eventManager.ghostCtx.clip()); for (var r = 0; r < a.dataSeriesIndexes.length; r++) {
                                            var h = a.dataSeriesIndexes[r], m = this.data[h], t = m.dataPoints; if (0 < t.length) {
                                                var x = 5 < g && m.bevelEnabled ? !0 : !1; c.strokeStyle = "#4572A7 "; for (k = 0; k < t.length; k++)if (b = t[k].x.getTime ? t[k].x.getTime() : t[k].x, !(b < a.axisX.dataInfo.viewPortMin || b > a.axisX.dataInfo.viewPortMax) && "number" === typeof t[k].y) {
                                                    p = a.axisX.convertValueToPixel(b); var s; s = 0 !== a.dataPointYSums[b] ? 100 * (t[k].y / a.dataPointYSums[b]) : 0; var E =
                                                        p - a.plotType.plotUnits.length * g / 2 + a.index * g << 0, C = E + g << 0; if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 < t[k].y) { u[b] = s + (u[b] ? u[b] : 0); if (0 >= u[b]) continue; s = f[b] ? f[b] : q; f[b] = n = a.axisY.convertValueToPixel(u[b]) } else if (a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length && 0 >= t[k].y) A[b] = s + (A[b] ? A[b] : 0), n = l[b] ? l[b] : q, l[b] = s = a.axisY.convertValueToPixel(A[b]); else if (n = a.axisY.convertValueToPixel(s), 0 <= t[k].y) {
                                                            var B = f[b] ? f[b] : 0; s = q + B; n += B; a.dataSeriesIndexes.length -
                                                                1 === r && 1 >= Math.abs(e.x2 - n) && (n = e.x2); f[b] = B + (n - s)
                                                        } else B = l[b] ? l[b] : 0, s = n - B, n = q - B, a.dataSeriesIndexes.length - 1 === r && 1 >= Math.abs(e.x1 - s) && (s = e.x1), l[b] = B + (n - s); b = t[k].color ? t[k].color : m._colorSet[k % m._colorSet.length]; ca(c, s, E, n, C, b, 0, null, x, !1, !1, !1, m.fillOpacity); b = m.dataPointIds[k]; this._eventManager.objectMap[b] = { id: b, objectType: "dataPoint", dataSeriesIndex: h, dataPointIndex: k, x1: s, y1: E, x2: n, y2: C }; b = Q(b); v && ca(this._eventManager.ghostCtx, s, E, n, C, b, 0, null, !1, !1, !1, !1); (t[k].indexLabel || m.indexLabel ||
                                                            t[k].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedBar100", dataPoint: t[k], dataSeries: m, point: { x: 0 <= t[k].y ? n : s, y: p }, direction: 0 > t[k].y === a.axisY.reversed ? 1 : -1, bounds: { x1: Math.min(s, n), y1: E, x2: Math.max(s, n), y2: C }, color: b })
                                                }
                                            }
                                        } v && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas,
                                            0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(e.x1, e.y1, e.width, e.height), this._eventManager.ghostCtx.restore()); c.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: L.xScaleAnimation, easingFunction: L.easing.easeOutQuart, animationBase: q < a.axisY.bounds.x1 ? a.axisY.bounds.x1 : q > a.axisY.bounds.x2 ? a.axisY.bounds.x2 : q }
                            }
                        }; m.prototype.renderArea = function (a) {
                            var d, c; function b() {
                                C && (0 < g.lineThickness &&
                                    f.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? E = z : 0 > a.axisY.viewportMaximum ? E = u.y1 : 0 < a.axisY.viewportMinimum && (E = z), f.lineTo(m, E), f.lineTo(C.x, E), f.closePath(), f.globalAlpha = g.fillOpacity, f.fill(), f.globalAlpha = 1, v && (l.lineTo(m, E), l.lineTo(C.x, E), l.closePath(), l.fill()), f.beginPath(), f.moveTo(m, t), l.beginPath(), l.moveTo(m, t), C = { x: m, y: t })
                            } var e = a.targetCanvasCtx || this.plotArea.ctx, f = v ? this._preRenderCtx : e; if (!(0 >= a.dataSeriesIndexes.length)) {
                                var l = this._eventManager.ghostCtx,
                                u = a.axisY.lineCoordinates, A = [], k = this.plotArea, n; f.save(); v && l.save(); f.beginPath(); f.rect(k.x1, k.y1, k.width, k.height); f.clip(); v && (l.beginPath(), l.rect(k.x1, k.y1, k.width, k.height), l.clip()); for (var p = 0; p < a.dataSeriesIndexes.length; p++) {
                                    var q = a.dataSeriesIndexes[p], g = this.data[q], r = g.dataPoints, A = g.id; this._eventManager.objectMap[A] = { objectType: "dataSeries", dataSeriesIndex: q }; A = Q(A); l.fillStyle = A; A = []; d = !0; var h = 0, m, t, s, z = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0),
                                        E, C = null; if (0 < r.length) {
                                            var B = g._colorSet[h % g._colorSet.length], w = g.lineColor = g.options.lineColor || B, y = w; f.fillStyle = B; f.strokeStyle = w; f.lineWidth = g.lineThickness; c = "solid"; if (f.setLineDash) { var S = N(g.nullDataLineDashType, g.lineThickness); c = g.lineDashType; var P = N(c, g.lineThickness); f.setLineDash(P) } for (var ja = !0; h < r.length; h++)if (s = r[h].x.getTime ? r[h].x.getTime() : r[h].x, !(s < a.axisX.dataInfo.viewPortMin || s > a.axisX.dataInfo.viewPortMax && (!g.connectNullData || !ja))) if ("number" !== typeof r[h].y) g.connectNullData ||
                                                (ja || d) || b(), ja = !0; else {
                                                    m = a.axisX.convertValueToPixel(s); t = a.axisY.convertValueToPixel(r[h].y); d || ja ? (!d && g.connectNullData ? (f.setLineDash && (g.options.nullDataLineDashType || c === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (d = m, c = t, m = n.x, t = n.y, b(), f.moveTo(n.x, n.y), m = d, t = c, C = n, c = g.nullDataLineDashType, f.setLineDash(S)), f.lineTo(m, t), v && l.lineTo(m, t)) : (f.beginPath(), f.moveTo(m, t), v && (l.beginPath(), l.moveTo(m, t)), C = { x: m, y: t }), ja = d = !1) : (f.lineTo(m, t), v && l.lineTo(m, t), 0 == h % 250 && b()); n = {
                                                        x: m,
                                                        y: t
                                                    }; h < r.length - 1 && (y !== (r[h].lineColor || w) || c !== (r[h].lineDashType || g.lineDashType)) && (b(), y = r[h].lineColor || w, f.strokeStyle = y, f.setLineDash && (r[h].lineDashType ? (c = r[h].lineDashType, f.setLineDash(N(c, g.lineThickness))) : (c = g.lineDashType, f.setLineDash(P)))); var aa = g.dataPointIds[h]; this._eventManager.objectMap[aa] = { id: aa, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: h, x1: m, y1: t }; 0 !== r[h].markerSize && (0 < r[h].markerSize || 0 < g.markerSize) && (s = g.getMarkerProperties(h, m, t, f), A.push(s), aa = Q(aa),
                                                        v && A.push({ x: m, y: t, ctx: l, type: s.type, size: s.size, color: aa, borderColor: aa, borderThickness: s.borderThickness })); (r[h].indexLabel || g.indexLabel || r[h].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "area", dataPoint: r[h], dataSeries: g, point: { x: m, y: t }, direction: 0 > r[h].y === a.axisY.reversed ? 1 : -1, color: B })
                                            } b(); W.drawMarkers(A)
                                        }
                                } v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), f.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && f.drawImage(a.axisX.maskCanvas,
                                    0, 0, this.width, this.height), a.axisY.maskCanvas && f.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), f.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore()); f.restore(); return { source: e, dest: this.plotArea.ctx, animationCallback: L.xClipAnimation, easingFunction: L.easing.linear, animationBase: 0 }
                            }
                        }; m.prototype.renderSplineArea = function (a) {
                            function d() {
                                var c = w(s, 2); if (0 < c.length) {
                                    if (0 <
                                        n.lineThickness) {
                                            b.beginPath(); b.moveTo(c[0].x, c[0].y); c[0].newStrokeStyle && (b.strokeStyle = c[0].newStrokeStyle); c[0].newLineDashArray && b.setLineDash(c[0].newLineDashArray); for (var d = 0; d < c.length - 3; d += 3)if (b.bezierCurveTo(c[d + 1].x, c[d + 1].y, c[d + 2].x, c[d + 2].y, c[d + 3].x, c[d + 3].y), v && e.bezierCurveTo(c[d + 1].x, c[d + 1].y, c[d + 2].x, c[d + 2].y, c[d + 3].x, c[d + 3].y), c[d + 3].newStrokeStyle || c[d + 3].newLineDashArray) b.stroke(), b.beginPath(), b.moveTo(c[d + 3].x, c[d + 3].y), c[d + 3].newStrokeStyle && (b.strokeStyle = c[d + 3].newStrokeStyle),
                                                c[d + 3].newLineDashArray && b.setLineDash(c[d + 3].newLineDashArray); b.stroke()
                                    } b.beginPath(); b.moveTo(c[0].x, c[0].y); v && (e.beginPath(), e.moveTo(c[0].x, c[0].y)); for (d = 0; d < c.length - 3; d += 3)b.bezierCurveTo(c[d + 1].x, c[d + 1].y, c[d + 2].x, c[d + 2].y, c[d + 3].x, c[d + 3].y), v && e.bezierCurveTo(c[d + 1].x, c[d + 1].y, c[d + 2].x, c[d + 2].y, c[d + 3].x, c[d + 3].y); a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? m = h : 0 > a.axisY.viewportMaximum ? m = f.y1 : 0 < a.axisY.viewportMinimum && (m = h); t = { x: c[0].x, y: c[0].y }; b.lineTo(c[c.length -
                                        1].x, m); b.lineTo(t.x, m); b.closePath(); b.globalAlpha = n.fillOpacity; b.fill(); b.globalAlpha = 1; v && (e.lineTo(c[c.length - 1].x, m), e.lineTo(t.x, m), e.closePath(), e.fill())
                                }
                            } var c = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : c; if (!(0 >= a.dataSeriesIndexes.length)) {
                                var e = this._eventManager.ghostCtx, f = a.axisY.lineCoordinates, l = [], u = this.plotArea; b.save(); v && e.save(); b.beginPath(); b.rect(u.x1, u.y1, u.width, u.height); b.clip(); v && (e.beginPath(), e.rect(u.x1, u.y1, u.width, u.height), e.clip()); for (var A =
                                    0; A < a.dataSeriesIndexes.length; A++) {
                                        var k = a.dataSeriesIndexes[A], n = this.data[k], p = n.dataPoints, l = n.id; this._eventManager.objectMap[l] = { objectType: "dataSeries", dataSeriesIndex: k }; l = Q(l); e.fillStyle = l; var l = [], q = 0, g, r, h = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), m, t = null, s = []; if (0 < p.length) {
                                            var z = n._colorSet[q % n._colorSet.length], E = n.lineColor = n.options.lineColor || z, C = E; b.fillStyle = z; b.strokeStyle = E; b.lineWidth = n.lineThickness; var B = "solid"; if (b.setLineDash) {
                                                var y = N(n.nullDataLineDashType,
                                                    n.lineThickness), B = n.lineDashType, D = N(B, n.lineThickness); b.setLineDash(D)
                                            } for (r = !1; q < p.length; q++)if (g = p[q].x.getTime ? p[q].x.getTime() : p[q].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax && (!n.connectNullData || !r))) if ("number" !== typeof p[q].y) 0 < q && !r && (n.connectNullData ? b.setLineDash && (0 < s.length && (n.options.nullDataLineDashType || !p[q - 1].lineDashType)) && (s[s.length - 1].newLineDashArray = y, B = n.nullDataLineDashType) : (d(), s = [])), r = !0; else {
                                                g = a.axisX.convertValueToPixel(g); r = a.axisY.convertValueToPixel(p[q].y);
                                                var S = n.dataPointIds[q]; this._eventManager.objectMap[S] = { id: S, objectType: "dataPoint", dataSeriesIndex: k, dataPointIndex: q, x1: g, y1: r }; s[s.length] = { x: g, y: r }; q < p.length - 1 && (C !== (p[q].lineColor || E) || B !== (p[q].lineDashType || n.lineDashType)) && (C = p[q].lineColor || E, s[s.length - 1].newStrokeStyle = C, b.setLineDash && (p[q].lineDashType ? (B = p[q].lineDashType, s[s.length - 1].newLineDashArray = N(B, n.lineThickness)) : (B = n.lineDashType, s[s.length - 1].newLineDashArray = D))); if (0 !== p[q].markerSize && (0 < p[q].markerSize || 0 < n.markerSize)) {
                                                    var P =
                                                        n.getMarkerProperties(q, g, r, b); l.push(P); S = Q(S); v && l.push({ x: g, y: r, ctx: e, type: P.type, size: P.size, color: S, borderColor: S, borderThickness: P.borderThickness })
                                                } (p[q].indexLabel || n.indexLabel || p[q].indexLabelFormatter || n.indexLabelFormatter) && this._indexLabels.push({ chartType: "splineArea", dataPoint: p[q], dataSeries: n, point: { x: g, y: r }, direction: 0 > p[q].y === a.axisY.reversed ? 1 : -1, color: z }); r = !1
                                            } d(); W.drawMarkers(l)
                                        }
                                } v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation =
                                    "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(u.x1, u.y1, u.width, u.height), this._eventManager.ghostCtx.restore()); b.restore(); return { source: c, dest: this.plotArea.ctx, animationCallback: L.xClipAnimation, easingFunction: L.easing.linear, animationBase: 0 }
                            }
                        }; m.prototype.renderStepArea =
                            function (a) {
                                var d, c; function b() { C && (0 < g.lineThickness && f.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? E = z : 0 > a.axisY.viewportMaximum ? E = u.y1 : 0 < a.axisY.viewportMinimum && (E = z), f.lineTo(m, E), f.lineTo(C.x, E), f.closePath(), f.globalAlpha = g.fillOpacity, f.fill(), f.globalAlpha = 1, v && (l.lineTo(m, E), l.lineTo(C.x, E), l.closePath(), l.fill()), f.beginPath(), f.moveTo(m, t), l.beginPath(), l.moveTo(m, t), C = { x: m, y: t }) } var e = a.targetCanvasCtx || this.plotArea.ctx, f = v ? this._preRenderCtx :
                                    e; if (!(0 >= a.dataSeriesIndexes.length)) {
                                        var l = this._eventManager.ghostCtx, u = a.axisY.lineCoordinates, A = [], k = this.plotArea, n; f.save(); v && l.save(); f.beginPath(); f.rect(k.x1, k.y1, k.width, k.height); f.clip(); v && (l.beginPath(), l.rect(k.x1, k.y1, k.width, k.height), l.clip()); for (var p = 0; p < a.dataSeriesIndexes.length; p++) {
                                            var q = a.dataSeriesIndexes[p], g = this.data[q], r = g.dataPoints, A = g.id; this._eventManager.objectMap[A] = { objectType: "dataSeries", dataSeriesIndex: q }; A = Q(A); l.fillStyle = A; A = []; d = !0; var h = 0, m, t, s, z = a.axisY.convertValueToPixel(a.axisY.logarithmic ?
                                                a.axisY.viewportMinimum : 0), E, C = null; c = !1; if (0 < r.length) {
                                                    var B = g._colorSet[h % g._colorSet.length], w = g.lineColor = g.options.lineColor || B, y = w; f.fillStyle = B; f.strokeStyle = w; f.lineWidth = g.lineThickness; var S = "solid"; if (f.setLineDash) { var P = N(g.nullDataLineDashType, g.lineThickness), S = g.lineDashType, D = N(S, g.lineThickness); f.setLineDash(D) } for (; h < r.length; h++)if (s = r[h].x.getTime ? r[h].x.getTime() : r[h].x, !(s < a.axisX.dataInfo.viewPortMin || s > a.axisX.dataInfo.viewPortMax && (!g.connectNullData || !c))) {
                                                        var aa = t; "number" !==
                                                            typeof r[h].y ? (g.connectNullData || (c || d) || b(), c = !0) : (m = a.axisX.convertValueToPixel(s), t = a.axisY.convertValueToPixel(r[h].y), d || c ? (!d && g.connectNullData ? (f.setLineDash && (g.options.nullDataLineDashType || S === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (d = m, c = t, m = n.x, t = n.y, b(), f.moveTo(n.x, n.y), m = d, t = c, C = n, S = g.nullDataLineDashType, f.setLineDash(P)), f.lineTo(m, aa), f.lineTo(m, t), v && (l.lineTo(m, aa), l.lineTo(m, t))) : (f.beginPath(), f.moveTo(m, t), v && (l.beginPath(), l.moveTo(m, t)), C = { x: m, y: t }), c =
                                                                d = !1) : (f.lineTo(m, aa), v && l.lineTo(m, aa), f.lineTo(m, t), v && l.lineTo(m, t), 0 == h % 250 && b()), n = { x: m, y: t }, h < r.length - 1 && (y !== (r[h].lineColor || w) || S !== (r[h].lineDashType || g.lineDashType)) && (b(), y = r[h].lineColor || w, f.strokeStyle = y, f.setLineDash && (r[h].lineDashType ? (S = r[h].lineDashType, f.setLineDash(N(S, g.lineThickness))) : (S = g.lineDashType, f.setLineDash(D)))), s = g.dataPointIds[h], this._eventManager.objectMap[s] = { id: s, objectType: "dataPoint", dataSeriesIndex: q, dataPointIndex: h, x1: m, y1: t }, 0 !== r[h].markerSize && (0 <
                                                                    r[h].markerSize || 0 < g.markerSize) && (aa = g.getMarkerProperties(h, m, t, f), A.push(aa), s = Q(s), v && A.push({ x: m, y: t, ctx: l, type: aa.type, size: aa.size, color: s, borderColor: s, borderThickness: aa.borderThickness })), (r[h].indexLabel || g.indexLabel || r[h].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({ chartType: "stepArea", dataPoint: r[h], dataSeries: g, point: { x: m, y: t }, direction: 0 > r[h].y === a.axisY.reversed ? 1 : -1, color: B }))
                                                    } b(); W.drawMarkers(A)
                                                }
                                        } v && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height),
                                            f.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && f.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && f.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), f.clearRect(k.x1, k.y1, k.width, k.height), this._eventManager.ghostCtx.restore()); f.restore(); return { source: e, dest: this.plotArea.ctx, animationCallback: L.xClipAnimation, easingFunction: L.easing.linear, animationBase: 0 }
                                    }
                            };
                m.prototype.renderStackedArea = function (a) {
                    function d() { if (!(1 > k.length)) { for (0 < B.lineThickness && b.stroke(); 0 < k.length;) { var a = k.pop(); b.lineTo(a.x, a.y); v && s.lineTo(a.x, a.y) } b.closePath(); b.globalAlpha = B.fillOpacity; b.fill(); b.globalAlpha = 1; b.beginPath(); v && (s.closePath(), s.fill(), s.beginPath()); k = [] } } var c = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : c; if (!(0 >= a.dataSeriesIndexes.length)) {
                        var e = null, f = null, l = [], u = this.plotArea, h = [], k = [], n = [], p = [], q = 0, g, r, m = a.axisY.convertValueToPixel(a.axisY.logarithmic ?
                            a.axisY.viewportMinimum : 0), s = this._eventManager.ghostCtx, t, x, z; v && s.beginPath(); b.save(); v && s.save(); b.beginPath(); b.rect(u.x1, u.y1, u.width, u.height); b.clip(); v && (s.beginPath(), s.rect(u.x1, u.y1, u.width, u.height), s.clip()); for (var e = [], E = 0; E < a.dataSeriesIndexes.length; E++) { var C = a.dataSeriesIndexes[E], B = this.data[C], w = B.dataPoints; B.dataPointIndexes = []; for (q = 0; q < w.length; q++)C = w[q].x.getTime ? w[q].x.getTime() : w[q].x, B.dataPointIndexes[C] = q, e[C] || (n.push(C), e[C] = !0); n.sort(Pa) } for (E = 0; E < a.dataSeriesIndexes.length; E++) {
                                C =
                                a.dataSeriesIndexes[E]; B = this.data[C]; w = B.dataPoints; x = !0; k = []; q = B.id; this._eventManager.objectMap[q] = { objectType: "dataSeries", dataSeriesIndex: C }; q = Q(q); s.fillStyle = q; if (0 < n.length) {
                                    var e = B._colorSet[0], y = B.lineColor = B.options.lineColor || e, S = y; b.fillStyle = e; b.strokeStyle = y; b.lineWidth = B.lineThickness; z = "solid"; if (b.setLineDash) { var P = N(B.nullDataLineDashType, B.lineThickness); z = B.lineDashType; var D = N(z, B.lineThickness); b.setLineDash(D) } for (var aa = !0, q = 0; q < n.length; q++) {
                                        var f = n[q], fa = null, fa = 0 <= B.dataPointIndexes[f] ?
                                            w[B.dataPointIndexes[f]] : { x: f, y: null }; if (!(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax && (!B.connectNullData || !aa))) if ("number" !== typeof fa.y) B.connectNullData || (aa || x) || d(), aa = !0; else {
                                                g = a.axisX.convertValueToPixel(f); var la = h[f] ? h[f] : 0; if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) { p[f] = fa.y + (p[f] ? p[f] : 0); if (0 >= p[f] && a.axisY.logarithmic) continue; r = a.axisY.convertValueToPixel(p[f]) } else r = a.axisY.convertValueToPixel(fa.y), r -= la; k.push({
                                                    x: g,
                                                    y: m - la
                                                }); h[f] = m - r; x || aa ? (!x && B.connectNullData ? (b.setLineDash && (B.options.nullDataLineDashType || z === B.lineDashType && B.lineDashType !== B.nullDataLineDashType) && (x = k.pop(), z = k[k.length - 1], d(), b.moveTo(t.x, t.y), k.push(z), k.push(x), z = B.nullDataLineDashType, b.setLineDash(P)), b.lineTo(g, r), v && s.lineTo(g, r)) : (b.beginPath(), b.moveTo(g, r), v && (s.beginPath(), s.moveTo(g, r))), aa = x = !1) : (b.lineTo(g, r), v && s.lineTo(g, r), 0 == q % 250 && (d(), b.moveTo(g, r), v && s.moveTo(g, r), k.push({ x: g, y: m - la }))); t = { x: g, y: r }; q < w.length - 1 &&
                                                    (S !== (w[q].lineColor || y) || z !== (w[q].lineDashType || B.lineDashType)) && (d(), b.beginPath(), b.moveTo(g, r), k.push({ x: g, y: m - la }), S = w[q].lineColor || y, b.strokeStyle = S, b.setLineDash && (w[q].lineDashType ? (z = w[q].lineDashType, b.setLineDash(N(z, B.lineThickness))) : (z = B.lineDashType, b.setLineDash(D)))); if (0 <= B.dataPointIndexes[f]) { var F = B.dataPointIds[B.dataPointIndexes[f]]; this._eventManager.objectMap[F] = { id: F, objectType: "dataPoint", dataSeriesIndex: C, dataPointIndex: B.dataPointIndexes[f], x1: g, y1: r } } 0 <= B.dataPointIndexes[f] &&
                                                        0 !== fa.markerSize && (0 < fa.markerSize || 0 < B.markerSize) && (la = B.getMarkerProperties(B.dataPointIndexes[f], g, r, b), l.push(la), f = Q(F), v && l.push({ x: g, y: r, ctx: s, type: la.type, size: la.size, color: f, borderColor: f, borderThickness: la.borderThickness })); (fa.indexLabel || B.indexLabel || fa.indexLabelFormatter || B.indexLabelFormatter) && this._indexLabels.push({ chartType: "stackedArea", dataPoint: fa, dataSeries: B, point: { x: g, y: r }, direction: 0 > w[q].y === a.axisY.reversed ? 1 : -1, color: e })
                                            }
                                    } d(); b.moveTo(g, r); v && s.moveTo(g, r)
                                } delete B.dataPointIndexes
                            } W.drawMarkers(l);
                        v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.clearRect(u.x1, u.y1, u.width, u.height), s.restore()); b.restore(); return {
                            source: c, dest: this.plotArea.ctx, animationCallback: L.xClipAnimation,
                            easingFunction: L.easing.linear, animationBase: 0
                        }
                    }
                }; m.prototype.renderStackedArea100 = function (a) {
                    function d() { for (0 < B.lineThickness && b.stroke(); 0 < k.length;) { var a = k.pop(); b.lineTo(a.x, a.y); v && z.lineTo(a.x, a.y) } b.closePath(); b.globalAlpha = B.fillOpacity; b.fill(); b.globalAlpha = 1; b.beginPath(); v && (z.closePath(), z.fill(), z.beginPath()); k = [] } var c = a.targetCanvasCtx || this.plotArea.ctx, b = v ? this._preRenderCtx : c; if (!(0 >= a.dataSeriesIndexes.length)) {
                        var e = null, f = null, l = this.plotArea, u = [], h = [], k = [], n = [], p = [], q =
                            0, g, r, m, s, t, x = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0), z = this._eventManager.ghostCtx; b.save(); v && z.save(); b.beginPath(); b.rect(l.x1, l.y1, l.width, l.height); b.clip(); v && (z.beginPath(), z.rect(l.x1, l.y1, l.width, l.height), z.clip()); for (var e = [], E = 0; E < a.dataSeriesIndexes.length; E++) {
                                var w = a.dataSeriesIndexes[E], B = this.data[w], y = B.dataPoints; B.dataPointIndexes = []; for (q = 0; q < y.length; q++)w = y[q].x.getTime ? y[q].x.getTime() : y[q].x, B.dataPointIndexes[w] = q, e[w] || (n.push(w), e[w] =
                                    !0); n.sort(Pa)
                            } for (E = 0; E < a.dataSeriesIndexes.length; E++) {
                                w = a.dataSeriesIndexes[E]; B = this.data[w]; y = B.dataPoints; s = !0; e = B.id; this._eventManager.objectMap[e] = { objectType: "dataSeries", dataSeriesIndex: w }; e = Q(e); z.fillStyle = e; k = []; if (0 < n.length) {
                                    var e = B._colorSet[q % B._colorSet.length], D = B.lineColor = B.options.lineColor || e, S = D; b.fillStyle = e; b.strokeStyle = D; b.lineWidth = B.lineThickness; t = "solid"; if (b.setLineDash) { var P = N(B.nullDataLineDashType, B.lineThickness); t = B.lineDashType; var F = N(t, B.lineThickness); b.setLineDash(F) } for (var aa =
                                        !0, q = 0; q < n.length; q++) {
                                            var f = n[q], fa = null, fa = 0 <= B.dataPointIndexes[f] ? y[B.dataPointIndexes[f]] : { x: f, y: null }; if (!(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax && (!B.connectNullData || !aa))) if ("number" !== typeof fa.y) B.connectNullData || (aa || s) || d(), aa = !0; else {
                                                var la; la = 0 !== a.dataPointYSums[f] ? 100 * (fa.y / a.dataPointYSums[f]) : 0; g = a.axisX.convertValueToPixel(f); var ba = h[f] ? h[f] : 0; if (a.axisY.logarithmic || a.axisY.scaleBreaks && 0 < a.axisY.scaleBreaks._appliedBreaks.length) {
                                                    p[f] = la + (p[f] ? p[f] :
                                                        0); if (0 >= p[f] && a.axisY.logarithmic) continue; r = a.axisY.convertValueToPixel(p[f])
                                                } else r = a.axisY.convertValueToPixel(la), r -= ba; k.push({ x: g, y: x - ba }); h[f] = x - r; s || aa ? (!s && B.connectNullData ? (b.setLineDash && (B.options.nullDataLineDashType || t === B.lineDashType && B.lineDashType !== B.nullDataLineDashType) && (s = k.pop(), t = k[k.length - 1], d(), b.moveTo(m.x, m.y), k.push(t), k.push(s), t = B.nullDataLineDashType, b.setLineDash(P)), b.lineTo(g, r), v && z.lineTo(g, r)) : (b.beginPath(), b.moveTo(g, r), v && (z.beginPath(), z.moveTo(g, r))),
                                                    aa = s = !1) : (b.lineTo(g, r), v && z.lineTo(g, r), 0 == q % 250 && (d(), b.moveTo(g, r), v && z.moveTo(g, r), k.push({ x: g, y: x - ba }))); m = { x: g, y: r }; q < y.length - 1 && (S !== (y[q].lineColor || D) || t !== (y[q].lineDashType || B.lineDashType)) && (d(), b.beginPath(), b.moveTo(g, r), k.push({ x: g, y: x - ba }), S = y[q].lineColor || D, b.strokeStyle = S, b.setLineDash && (y[q].lineDashType ? (t = y[q].lineDashType, b.setLineDash(N(t, B.lineThickness))) : (t = B.lineDashType, b.setLineDash(F)))); if (0 <= B.dataPointIndexes[f]) {
                                                        var G = B.dataPointIds[B.dataPointIndexes[f]]; this._eventManager.objectMap[G] =
                                                            { id: G, objectType: "dataPoint", dataSeriesIndex: w, dataPointIndex: B.dataPointIndexes[f], x1: g, y1: r }
                                                    } 0 <= B.dataPointIndexes[f] && 0 !== fa.markerSize && (0 < fa.markerSize || 0 < B.markerSize) && (ba = B.getMarkerProperties(q, g, r, b), u.push(ba), f = Q(G), v && u.push({ x: g, y: r, ctx: z, type: ba.type, size: ba.size, color: f, borderColor: f, borderThickness: ba.borderThickness })); (fa.indexLabel || B.indexLabel || fa.indexLabelFormatter || B.indexLabelFormatter) && this._indexLabels.push({
                                                        chartType: "stackedArea100", dataPoint: fa, dataSeries: B, point: {
                                                            x: g,
                                                            y: r
                                                        }, direction: 0 > y[q].y === a.axisY.reversed ? 1 : -1, color: e
                                                    })
                                            }
                                    } d(); b.moveTo(g, r); v && z.moveTo(g, r)
                                } delete B.dataPointIndexes
                            } W.drawMarkers(u); v && (c.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), b.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && b.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && b.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height),
                                b.clearRect(l.x1, l.y1, l.width, l.height), z.restore()); b.restore(); return { source: c, dest: this.plotArea.ctx, animationCallback: L.xClipAnimation, easingFunction: L.easing.linear, animationBase: 0 }
                    }
                }; m.prototype.renderBubble = function (a) {
                    var d = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                        var b = this.plotArea, e = 0, f, l; c.save(); v && this._eventManager.ghostCtx.save(); c.beginPath(); c.rect(b.x1, b.y1, b.width, b.height); c.clip(); v && (this._eventManager.ghostCtx.beginPath(),
                            this._eventManager.ghostCtx.rect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.clip()); for (var u = -Infinity, h = Infinity, k = 0; k < a.dataSeriesIndexes.length; k++)for (var n = a.dataSeriesIndexes[k], p = this.data[n], q = p.dataPoints, g = 0, e = 0; e < q.length; e++)f = q[e].getTime ? f = q[e].x.getTime() : f = q[e].x, f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax || "undefined" === typeof q[e].z || (g = q[e].z, g > u && (u = g), g < h && (h = g)); for (var r = 25 * Math.PI, m = Math.max(Math.pow(0.25 * Math.min(b.height, b.width) / 2, 2) * Math.PI,
                                r), k = 0; k < a.dataSeriesIndexes.length; k++)if (n = a.dataSeriesIndexes[k], p = this.data[n], q = p.dataPoints, 0 < q.length) for (c.strokeStyle = "#4572A7 ", e = 0; e < q.length; e++)if (f = q[e].getTime ? f = q[e].x.getTime() : f = q[e].x, !(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax) && "number" === typeof q[e].y) {
                                    f = a.axisX.convertValueToPixel(f); l = a.axisY.convertValueToPixel(q[e].y); var g = q[e].z, s = 2 * Math.max(Math.sqrt((u === h ? m / 2 : r + (m - r) / (u - h) * (g - h)) / Math.PI) << 0, 1), g = p.getMarkerProperties(e, c); g.size = s; c.globalAlpha =
                                        p.fillOpacity; W.drawMarker(f, l, c, g.type, g.size, g.color, g.borderColor, g.borderThickness); c.globalAlpha = 1; var t = p.dataPointIds[e]; this._eventManager.objectMap[t] = { id: t, objectType: "dataPoint", dataSeriesIndex: n, dataPointIndex: e, x1: f, y1: l, size: s }; s = Q(t); v && W.drawMarker(f, l, this._eventManager.ghostCtx, g.type, g.size, s, s, g.borderThickness); (q[e].indexLabel || p.indexLabel || q[e].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({
                                            chartType: "bubble", dataPoint: q[e], dataSeries: p, point: { x: f, y: l },
                                            direction: 1, bounds: { x1: f - g.size / 2, y1: l - g.size / 2, x2: f + g.size / 2, y2: l + g.size / 2 }, color: null
                                        })
                                } v && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.restore());
                        c.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: L.fadeInAnimation, easingFunction: L.easing.easeInQuad, animationBase: 0 }
                    }
                }; m.prototype.renderScatter = function (a) {
                    var d = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : d; if (!(0 >= a.dataSeriesIndexes.length)) {
                        var b = this.plotArea, e = 0, f, l; c.save(); v && this._eventManager.ghostCtx.save(); c.beginPath(); c.rect(b.x1, b.y1, b.width, b.height); c.clip(); v && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(b.x1, b.y1,
                            b.width, b.height), this._eventManager.ghostCtx.clip()); for (var u = 0; u < a.dataSeriesIndexes.length; u++) {
                                var h = a.dataSeriesIndexes[u], k = this.data[h], n = k.dataPoints; if (0 < n.length) {
                                    c.strokeStyle = "#4572A7 "; Math.pow(0.3 * Math.min(b.height, b.width) / 2, 2); for (var p = 0, q = 0, e = 0; e < n.length; e++)if (f = n[e].getTime ? f = n[e].x.getTime() : f = n[e].x, !(f < a.axisX.dataInfo.viewPortMin || f > a.axisX.dataInfo.viewPortMax) && "number" === typeof n[e].y) {
                                        f = a.axisX.convertValueToPixel(f); l = a.axisY.convertValueToPixel(n[e].y); var g = k.getMarkerProperties(e,
                                            f, l, c); c.globalAlpha = k.fillOpacity; W.drawMarker(g.x, g.y, g.ctx, g.type, g.size, g.color, g.borderColor, g.borderThickness); c.globalAlpha = 1; Math.sqrt((p - f) * (p - f) + (q - l) * (q - l)) < Math.min(g.size, 5) && n.length > Math.min(this.plotArea.width, this.plotArea.height) || (p = k.dataPointIds[e], this._eventManager.objectMap[p] = { id: p, objectType: "dataPoint", dataSeriesIndex: h, dataPointIndex: e, x1: f, y1: l }, p = Q(p), v && W.drawMarker(g.x, g.y, this._eventManager.ghostCtx, g.type, g.size, p, p, g.borderThickness), (n[e].indexLabel || k.indexLabel ||
                                                n[e].indexLabelFormatter || k.indexLabelFormatter) && this._indexLabels.push({ chartType: "scatter", dataPoint: n[e], dataSeries: k, point: { x: f, y: l }, direction: 1, bounds: { x1: f - g.size / 2, y1: l - g.size / 2, x2: f + g.size / 2, y2: l + g.size / 2 }, color: null }), p = f, q = l)
                                    }
                                }
                            } v && (d.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.globalCompositeOperation = "source-atop", a.axisX.maskCanvas && c.drawImage(a.axisX.maskCanvas, 0, 0, this.width, this.height), a.axisY.maskCanvas && c.drawImage(a.axisY.maskCanvas, 0, 0, this.width, this.height),
                                this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), c.clearRect(b.x1, b.y1, b.width, b.height), this._eventManager.ghostCtx.restore()); c.restore(); return { source: d, dest: this.plotArea.ctx, animationCallback: L.fadeInAnimation, easingFunction: L.easing.easeInQuad, animationBase: 0 }
                    }
                }; m.prototype.renderCandlestick = function (a) {
                    var d = a.targetCanvasCtx || this.plotArea.ctx, c = v ? this._preRenderCtx : d, b = this._eventManager.ghostCtx; if (!(0 >= a.dataSeriesIndexes.length)) {
                        var e =
                            null, f = null, l = this.plotArea, u = 0, h, k, n, p, q, g, e = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, f = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : 0.015 * this.width, r = a.axisX.dataInfo.minDiff; isFinite(r) || (r = 0.3 * Math.abs(a.axisX.range)); r = this.options.dataPointWidth ? this.dataPointWidth : 0.7 * l.width * (a.axisX.logarithmic ? Math.log(r) / Math.log(a.axisX.range) : Math.abs(r) / Math.abs(a.axisX.range)) << 0;
                        this.dataPointMaxWidth && e > f && (e = Math.min(this.options.dataPointWidth ? this.dataPointWidth : Infinity, f)); !this.dataPointMaxWidth && (this.dataPointMinWidth && f < e) && (f = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -Infinity, e)); r < e && (r = e); r > f && (r = f); c.save(); v && b.save(); c.beginPath(); c.rect(l.x1, l.y1, l.width, l.height); c.clip(); v && (b.beginPath(), b.rect(l.x1, l.y1, l.width, l.height), b.clip()); for (var m = 0; m < a.dataSeriesIndexes.length; m++) {
                            var w = a.dataSeriesIndexes[m], t = this.data[w], x = t.dataPoints;
                            if (0 < x.length) for (var z = 5 